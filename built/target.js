var pxtTargetBundle = {
  "id": "brainpad",
  "platformid": "codal",
  "nickname": "brainpad",
  "name": "GHI Brain Pad",
  "title": "GHI Brain Pad - Blocks / Javascript editor",
  "description": "A Blocks / JavaScript code editor for the GHI Brain Pad.",
  "corepkg": "brainpad",
  "bundleddirs": [
    "libs/base",
    "libs/core",
    "libs/buttons",
    "libs/accelerometer",
    "libs/music",
    "libs/microphone",
    "libs/lightsensor",
    "libs/thermometer",
    "libs/touch",
    "libs/switch",
    "libs/pulse",
    "libs/lightbulb",
    "libs/brainpad"
  ],
  "serial": {
    "useHF2": true,
    "useEditor": true,
    "log": true,
    "editorTheme": {
      "graphBackground": "#d9d9d9",
      "lineColors": [
        "#009DDC",
        "#FB48C7",
        "#40bf4a",
        "#8073E5",
        "#d25b33"
      ]
    }
  },
  "simulator": {
    "autoRun": true,
    "streams": false,
    "aspectRatio": 1.8,
    "parts": false,
    "enableTrace": true,
    "boardDefinition": {
      "visual": "brainpad",
      "gpioPinBlocks": [
        [
          "P0"
        ],
        [
          "P1"
        ],
        [
          "P2"
        ],
        [
          "P3"
        ],
        [
          "P4",
          "P5",
          "P6",
          "P7"
        ],
        [
          "P8",
          "P9",
          "P10",
          "P11",
          "P12"
        ],
        [
          "P16"
        ]
      ],
      "gpioPinMap": {
        "P0": "P0",
        "P1": "P1",
        "P2": "P2",
        "P3": "P3",
        "P4": "P4",
        "P5": "P5",
        "P6": "P6",
        "P7": "P7",
        "P8": "P8",
        "P9": "P9",
        "P10": "P10",
        "P11": "P11",
        "P12": "P12",
        "P13": "P13",
        "P14": "P14",
        "P15": "P15",
        "P16": "P16",
        "P19": "P19",
        "P20": "P20"
      },
      "i2cPins": {
        "SDA": "P2",
        "SCL": "P3"
      },
      "analogInPins": [
        "A0",
        "A4",
        "A5"
      ],
      "groundPins": [
        "GND_0",
        "GND_1",
        "GND_2"
      ],
      "threeVoltPins": [
        "PWR_0",
        "PWR_2"
      ],
      "attachPowerOnRight": true,
      "onboardComponents": [
        "accelerometer",
        "buttonpair",
        "speaker",
        "thermometer",
        "rgbsensor",
        "lightsensor",
        "microphone"
      ],
      "useCrocClips": true,
      "marginWhenBreadboarding": [
        0,
        0,
        80,
        0
      ]
    }
  },
  "cloud": {
    "workspace": false,
    "packages": true,
    "sharing": true,
    "publishing": true,
    "importing": false,
    "preferredPackages": [],
    "githubPackages": true
  },
  "compile": {
    "isNative": true,
    "useUF2": true,
    "hasHex": true,
    "deployDrives": ".*",
    "deployFileMarker": "INFO_UF2.TXT",
    "driveName": "CPLAYBOOT",
    "openocdScript": "source [find interface/cmsis-dap.cfg]; set CHIPNAME at91samd21g18; source [find target/at91samdXX.cfg]",
    "flashChecksumAddr": 8372,
    "flashCodeAlign": 256,
    "floatingPoint": true,
    "taggedInts": true,
    "upgrades": [
      {
        "type": "package",
        "map": {}
      },
      {
        "type": "api",
        "map": {}
      }
    ],
    "hidSelectors": [
      {
        "usagePage": "0xFF97",
        "usageId": "0x0001",
        "vid": "0x239A",
        "pid": "0x0018"
      },
      {
        "usagePage": "0xFF00",
        "usageId": "0x0001",
        "vid": "0x239A",
        "pid": "0x0018"
      },
      {
        "usagePage": "0xFF00",
        "usageId": "0x0001",
        "vid": "0x239A",
        "pid": "0x0019"
      },
      {
        "usagePage": "0xFF97",
        "usageId": "0x0001",
        "vid": "0x03EB",
        "pid": "0x2402"
      }
    ],
    "jsRefCounting": true,
    "nativeType": "thumb",
    "needsUnboxing": true
  },
  "runtime": {
    "mathBlocks": true,
    "loopsBlocks": true,
    "logicBlocks": true,
    "variablesBlocks": true,
    "textBlocks": true,
    "listsBlocks": true,
    "functionBlocks": true,
    "onStartNamespace": "loops",
    "onStartColor": "#40bf4a",
    "onStartWeight": 100
  },
  "compileService": {
    "buildEngine": "codal",
    "codalTarget": {
      "name": "codal-circuit-playground",
      "url": "https://github.com/lancaster-university/codal-circuit-playground",
      "branch": "v1.2.8",
      "type": "git"
    },
    "codalBinary": "CIRCUIT_PLAYGROUND",
    "yottaConfig": {
      "pxt": {
        "board": {
          "id": "BOARD_ID_CPLAY"
        }
      }
    },
    "githubCorePackage": "lancaster-university/codal",
    "gittag": "v0.2.2",
    "serviceId": "codal2cp"
  },
  "appTheme": {
    "accentColor": "#0089BF",
    "logoUrl": "https://old.ghielectronics.com/catalog/product/536",
    "logo": "data:image/png;base64,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",
    "docsLogo": "data:image/png;base64,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",
    "portraitLogo": "data:image/png;base64,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",
    "footerLogo": "data:image/png;base64,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",
    "organization": "Microsoft MakeCode",
    "organizationUrl": "https://makecode.com/",
    "organizationLogo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAS0AAAEtCAMAAABqPcbcAAAABGdBTUEAALGPC/xhBQAAAwBQTFRFAAAAf7oAAKTvP7ryb8v18lAi9XtYnss/tthv/7kA/8o//9dv95yCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApRt6LQAAAQB0Uk5T////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AFP3ByUAAAAJcEhZcwAALiEAAC4hAQdb/P8AAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTJDBGvsAAACn0lEQVR4Xu3QsVUDMRQAQYHB5gz9tyuSX8BtpmCmgn27Nvet/X2U53SN18dR3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq1n4e5W82jZ/XUdZkcYdbhVuFW4VbhVuFW4VbhVuFW4VbhVuFW4VbxdqPo3xN1/h9H2Xtz6M8ZtN4X0dxq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcKtwq3CrcOu+6/oHGlSc5B6nYrEAAAAASUVORK5CYII=",
    "organizationWideLogo": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABmcAAAFeCAMAAABHKDtZAAAAdVBMVEUAAADyUCKAugGAugHyUCLyUCKAugGAugGAugH///////////////////////////////////////////////////////////+AugHyUCICpO8CpO8CpO8CpO//uQL/uQL/uQL/uQLyUCKAugH///8CpO//uQLk57r3AAAAInRSTlMAv4BAj4Cfr78wQFCAcBAgYL/fz6/vj58gQL+An2BAgL8wO9ga1QAAAAFiS0dECfHZpewAAAAJcEhZcwAAAJYAAACWAHFG/vAAAC7SSURBVHja7Z2Ldus8kl6dnkwmkiiJkigp6U7mFifv/4iR7WP/upDEV0ABIOm915pevaaPSZACsYFCAXj7z1nwX96e+Nv/mQX/9AYA8NupbRA8AwCwbGobBM8AACyb2gbBMwAAy6a2QfAMAMCyqW0QPAMAsGxqG0Tjvz4XG88AAMyE2gbR+OfnYuMZAICZUNsgeAYAYNnUNgieAQBYNrUNgmcAAJZNbYPgGQCAZVPbIHgGAGDZ1DYIngEAWDa1DYJnAACWTW2D4BkAgGVT2yB4BgBg2dQ2CJ4BAFg2tQ2CZwAAlk1tg+AZAIBlU9sgeAYAYNnUNgieAQBYNrUNgmcAAJZNbYPgGQCAZVPbIHgGAGDZ1DYIngEAWDa1DYJnAACWTW2D4BkAgGVT2yB4BgBg2dQ2CJ4BAFg2tQ0S6Zn/VtsgeAYAQKO2QSI9w3gGAGAm1DYIngEAWDa1DYJnAACWTW2D4BkAgGVT2yCRniEPAABgJtQ2SKRn/qW2QfAMAIBGbYNEeua/1zYIngEA0KhtEDwDALBsahsEzwAALJvaBsEzAADLprZB8AwAwLKpbRA8AwCwbGobBM8AACyb2gbBMwAAy6a2QfAMAMCyqW0QPAMAsGxqGwTPAAAsm9oGwTMAAMumtkHwDADAsqltEDwDALBsahsEzwAALJvaBsEzAADLprZB8AwAwLKpbRA8AwBQkNV60/zFdr3eZb9lbYPgGQCAIuzb5nB87+F0aDarjDeubRA8AwCQnf22O7+Pcj4060w3r20QPAMAkJf95fSukef+tQ2CZwAAMrJrVcngmUfwDABAmP31rFsGzzyAZwAAQuyvFsngmUfwDADAODurZfDMA3gGAGCUrSlihmfw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",
    "homeUrl": "https://makecode.ghielectronics.com/",
    "embedUrl": "https://makecode.ghielectronics.com/",
    "privacyUrl": "https://go.microsoft.com/fwlink/?LinkId=521839",
    "termsOfUseUrl": "https://go.microsoft.com/fwlink/?LinkID=206977",
    "githubUrl": "https://github.com/Microsoft/pxt-brainpad",
    "crowdinProject": "kindscript",
    "boardName": "Brain Pad",
    "driveDisplayName": "CPLAYBOOT",
    "docMenu": [
      {
        "name": "Blocks",
        "path": "/blocks"
      },
      {
        "name": "JavaScript",
        "path": "/javascript"
      },
      {
        "name": "Reference",
        "path": "/reference"
      },
      {
        "name": "Buy",
        "path": "https://old.ghielectronics.com/catalog/product/536"
      }
    ],
    "showHomeScreen": true,
    "homeScreenHero": "./static/getting-started/getting-started.png",
    "invertedMenu": true,
    "invertedToolbox": false,
    "invertedMonaco": false,
    "monacoToolbox": true,
    "selectLanguage": true,
    "simAnimationEnter": "fly right in",
    "simAnimationExit": "fly right out",
    "highContrast": true,
    "hasAudio": true,
    "usbHelp": [],
    "extendEditor": true,
    "disableBlockIcons": true,
    "socialOptions": {
      "twitterHandle": "ghielectronics",
      "orgTwitterHandle": "MSMakeCode",
      "hashtags": "MakeCode"
    },
    "blocklyOptions": {
      "grid": {}
    },
    "blocklyColors": {
      "insertionMarker": "#000000",
      "insertionMarkerOpacity": 0.5
    },
    "blockColors": {
      "loops": "#40bf4a",
      "logic": "#4cbfe6",
      "math": "#9966ff",
      "variables": "#FF6680",
      "text": "#ffab19",
      "advanced": "#00272B",
      "functions": "#005a9e",
      "arrays": "#8A1C7C"
    },
    "allowPackageExtensions": true,
    "TOC": [
      {
        "name": "Projects",
        "subitems": [],
        "path": "/projects",
        "nextName": "Examples",
        "nextPath": "/examples"
      },
      {
        "name": "Examples",
        "subitems": [],
        "path": "/examples",
        "prevName": "Projects",
        "prevPath": "/projects",
        "nextName": "Reference",
        "nextPath": "/reference"
      },
      {
        "name": "Reference",
        "subitems": [
          {
            "name": "input",
            "subitems": [],
            "path": "/reference/input",
            "prevName": "Reference",
            "prevPath": "/reference",
            "nextName": "music",
            "nextPath": "/reference/music"
          },
          {
            "name": "music",
            "subitems": [],
            "path": "/reference/music",
            "prevName": "input",
            "prevPath": "/reference/input",
            "nextName": "pins",
            "nextPath": "/reference/pins"
          },
          {
            "name": "pins",
            "subitems": [],
            "path": "/reference/pins",
            "prevName": "music",
            "prevPath": "/reference/music",
            "nextName": "control",
            "nextPath": "/reference/control"
          },
          {
            "name": "control",
            "subitems": [],
            "path": "/reference/control",
            "prevName": "pins",
            "prevPath": "/reference/pins",
            "nextName": "serial",
            "nextPath": "/reference/serial"
          },
          {
            "name": "serial",
            "subitems": [],
            "path": "/reference/serial",
            "prevName": "control",
            "prevPath": "/reference/control",
            "nextName": "Blocks",
            "nextPath": "/blocks"
          }
        ],
        "path": "/reference",
        "prevName": "Examples",
        "prevPath": "/examples",
        "nextName": "input",
        "nextPath": "/reference/input"
      },
      {
        "name": "Blocks",
        "subitems": [
          {
            "name": "On Start",
            "subitems": [],
            "path": "/blocks/on-start",
            "prevName": "Blocks",
            "prevPath": "/blocks",
            "nextName": "Loops",
            "nextPath": "/blocks/loops"
          },
          {
            "name": "Loops",
            "subitems": [
              {
                "name": "repeat",
                "subitems": [],
                "path": "/blocks/loops/repeat",
                "prevName": "Loops",
                "prevPath": "/blocks/loops",
                "nextName": "for",
                "nextPath": "/blocks/loops/for"
              },
              {
                "name": "for",
                "subitems": [],
                "path": "/blocks/loops/for",
                "prevName": "repeat",
                "prevPath": "/blocks/loops/repeat",
                "nextName": "while",
                "nextPath": "/blocks/loops/while"
              },
              {
                "name": "while",
                "subitems": [],
                "path": "/blocks/loops/while",
                "prevName": "for",
                "prevPath": "/blocks/loops/for",
                "nextName": "Logic",
                "nextPath": "/blocks/logic"
              }
            ],
            "path": "/blocks/loops",
            "prevName": "On Start",
            "prevPath": "/blocks/on-start",
            "nextName": "repeat",
            "nextPath": "/blocks/loops/repeat"
          },
          {
            "name": "Logic",
            "subitems": [
              {
                "name": "if",
                "subitems": [],
                "path": "/blocks/logic/if",
                "prevName": "Logic",
                "prevPath": "/blocks/logic",
                "nextName": "Boolean",
                "nextPath": "/blocks/logic/boolean"
              },
              {
                "name": "Boolean",
                "subitems": [],
                "path": "/blocks/logic/boolean",
                "prevName": "if",
                "prevPath": "/blocks/logic/if",
                "nextName": "Variables",
                "nextPath": "/blocks/variables"
              }
            ],
            "path": "/blocks/logic",
            "prevName": "while",
            "prevPath": "/blocks/loops/while",
            "nextName": "if",
            "nextPath": "/blocks/logic/if"
          },
          {
            "name": "Variables",
            "subitems": [
              {
                "name": "assign",
                "subitems": [],
                "path": "/blocks/variables/assign",
                "prevName": "Variables",
                "prevPath": "/blocks/variables",
                "nextName": "change var",
                "nextPath": "/blocks/variables/change"
              },
              {
                "name": "change var",
                "subitems": [],
                "path": "/blocks/variables/change",
                "prevName": "assign",
                "prevPath": "/blocks/variables/assign",
                "nextName": "var",
                "nextPath": "/blocks/variables/var"
              },
              {
                "name": "var",
                "subitems": [],
                "path": "/blocks/variables/var",
                "prevName": "change var",
                "prevPath": "/blocks/variables/change",
                "nextName": "Math",
                "nextPath": "/blocks/math"
              }
            ],
            "path": "/blocks/variables",
            "prevName": "Boolean",
            "prevPath": "/blocks/logic/boolean",
            "nextName": "assign",
            "nextPath": "/blocks/variables/assign"
          },
          {
            "name": "Math",
            "subitems": [],
            "path": "/blocks/math",
            "prevName": "var",
            "prevPath": "/blocks/variables/var",
            "nextName": "JavaScript blocks",
            "nextPath": "/blocks/javascript-blocks"
          },
          {
            "name": "JavaScript blocks",
            "subitems": [],
            "path": "/blocks/javascript-blocks",
            "prevName": "Math",
            "prevPath": "/blocks/math",
            "nextName": "Custom blocks",
            "nextPath": "/blocks/custom"
          },
          {
            "name": "Custom blocks",
            "subitems": [],
            "path": "/blocks/custom",
            "prevName": "JavaScript blocks",
            "prevPath": "/blocks/javascript-blocks",
            "nextName": "JavaScript",
            "nextPath": "/javascript"
          }
        ],
        "path": "/blocks",
        "prevName": "serial",
        "prevPath": "/reference/serial",
        "nextName": "On Start",
        "nextPath": "/blocks/on-start"
      },
      {
        "name": "JavaScript",
        "subitems": [
          {
            "name": "Calling",
            "subitems": [],
            "path": "/javascript/call",
            "prevName": "JavaScript",
            "prevPath": "/javascript",
            "nextName": "Sequencing",
            "nextPath": "/javascript/sequence"
          },
          {
            "name": "Sequencing",
            "subitems": [],
            "path": "/javascript/sequence",
            "prevName": "Calling",
            "prevPath": "/javascript/call",
            "nextName": "Variables",
            "nextPath": "/javascript/variables"
          },
          {
            "name": "Variables",
            "subitems": [],
            "path": "/javascript/variables",
            "prevName": "Sequencing",
            "prevPath": "/javascript/sequence",
            "nextName": "Operators",
            "nextPath": "/javascript/operators"
          },
          {
            "name": "Operators",
            "subitems": [],
            "path": "/javascript/operators",
            "prevName": "Variables",
            "prevPath": "/javascript/variables",
            "nextName": "Statements",
            "nextPath": "/javascript/statements"
          },
          {
            "name": "Statements",
            "subitems": [],
            "path": "/javascript/statements",
            "prevName": "Operators",
            "prevPath": "/javascript/operators",
            "nextName": "Functions",
            "nextPath": "/javascript/functions"
          },
          {
            "name": "Functions",
            "subitems": [],
            "path": "/javascript/functions",
            "prevName": "Statements",
            "prevPath": "/javascript/statements",
            "nextName": "Types",
            "nextPath": "/javascript/types"
          },
          {
            "name": "Types",
            "subitems": [],
            "path": "/javascript/types",
            "prevName": "Functions",
            "prevPath": "/javascript/functions",
            "nextName": "Classes",
            "nextPath": "/javascript/classes"
          },
          {
            "name": "Classes",
            "subitems": [],
            "path": "/javascript/classes",
            "prevName": "Types",
            "prevPath": "/javascript/types",
            "nextName": "Interfaces",
            "nextPath": "/javascript/interfaces"
          },
          {
            "name": "Interfaces",
            "subitems": [],
            "path": "/javascript/interfaces",
            "prevName": "Classes",
            "prevPath": "/javascript/classes",
            "nextName": "Generics",
            "nextPath": "/javascript/generics"
          },
          {
            "name": "Generics",
            "subitems": [],
            "path": "/javascript/generics",
            "prevName": "Interfaces",
            "prevPath": "/javascript/interfaces",
            "nextName": "Types",
            "nextPath": "/types"
          }
        ],
        "path": "/javascript",
        "prevName": "Custom blocks",
        "prevPath": "/blocks/custom",
        "nextName": "Calling",
        "nextPath": "/javascript/call"
      },
      {
        "name": "Types",
        "subitems": [
          {
            "name": "Number",
            "subitems": [],
            "path": "/types/number",
            "prevName": "Types",
            "prevPath": "/types",
            "nextName": "String",
            "nextPath": "/types/string"
          },
          {
            "name": "String",
            "subitems": [],
            "path": "/types/string",
            "prevName": "Number",
            "prevPath": "/types/number",
            "nextName": "Boolean",
            "nextPath": "/types/boolean"
          },
          {
            "name": "Boolean",
            "subitems": [],
            "path": "/types/boolean",
            "prevName": "String",
            "prevPath": "/types/string",
            "nextName": "Array",
            "nextPath": "/types/array"
          },
          {
            "name": "Array",
            "subitems": [],
            "path": "/types/array",
            "prevName": "Boolean",
            "prevPath": "/types/boolean",
            "nextName": "Function",
            "nextPath": "/types/function"
          },
          {
            "name": "Function",
            "subitems": [],
            "path": "/types/function",
            "prevName": "Array",
            "prevPath": "/types/array",
            "nextName": "Support",
            "nextPath": "/support"
          }
        ],
        "path": "/types",
        "prevName": "Generics",
        "prevPath": "/javascript/generics",
        "nextName": "Number",
        "nextPath": "/types/number"
      },
      {
        "name": "",
        "subitems": [
          {
            "name": "Support",
            "subitems": [],
            "path": "/support",
            "prevName": "Function",
            "prevPath": "/types/function",
            "nextName": "FAQ",
            "nextPath": "/faq"
          },
          {
            "name": "FAQ",
            "subitems": [],
            "path": "/faq",
            "prevName": "Support",
            "prevPath": "/support",
            "nextName": "Translate",
            "nextPath": "/translate"
          },
          {
            "name": "Translate",
            "subitems": [],
            "path": "/translate",
            "prevName": "FAQ",
            "prevPath": "/faq",
            "nextName": "Sharing projects",
            "nextPath": "/share"
          },
          {
            "name": "Sharing projects",
            "subitems": [],
            "path": "/share",
            "prevName": "Translate",
            "prevPath": "/translate",
            "nextName": "Offline support",
            "nextPath": "/offline"
          },
          {
            "name": "Offline support",
            "subitems": [],
            "path": "/offline",
            "prevName": "Sharing projects",
            "prevPath": "/share",
            "nextName": "Streaming",
            "nextPath": "/streaming"
          },
          {
            "name": "Streaming",
            "subitems": [],
            "path": "/streaming",
            "prevName": "Offline support",
            "prevPath": "/offline",
            "nextName": "Command Line Interface",
            "nextPath": "/cli"
          }
        ],
        "prevName": "Function",
        "prevPath": "/types/function"
      },
      {
        "name": "",
        "subitems": [
          {
            "name": "Command Line Interface",
            "subitems": [],
            "path": "/cli",
            "prevName": "Streaming",
            "prevPath": "/streaming",
            "nextName": "Visual Studio Code support",
            "nextPath": "/code"
          },
          {
            "name": "Visual Studio Code support",
            "subitems": [],
            "path": "/code",
            "prevName": "Command Line Interface",
            "prevPath": "/cli",
            "nextName": "Coding on Raspberry Pi",
            "nextPath": "/raspberry-pi"
          },
          {
            "name": "Coding on Raspberry Pi",
            "subitems": [],
            "path": "/raspberry-pi",
            "prevName": "Visual Studio Code support",
            "prevPath": "/code",
            "nextName": "Blocks Embed",
            "nextPath": "/blocks-embed"
          },
          {
            "name": "Blocks Embed",
            "subitems": [],
            "path": "/blocks-embed",
            "prevName": "Coding on Raspberry Pi",
            "prevPath": "/raspberry-pi",
            "nextName": "Hardware",
            "nextPath": "/device"
          }
        ],
        "prevName": "Streaming",
        "prevPath": "/streaming"
      },
      {
        "name": "Hardware",
        "subitems": [
          {
            "name": "Simulator",
            "subitems": [],
            "path": "/device/simulator",
            "prevName": "Hardware",
            "prevPath": "/device",
            "nextName": "USB",
            "nextPath": "/device/usb"
          },
          {
            "name": "USB",
            "subitems": [],
            "path": "/device/usb",
            "prevName": "Simulator",
            "prevPath": "/device/simulator"
          }
        ],
        "path": "/device",
        "prevName": "Blocks Embed",
        "prevPath": "/blocks-embed",
        "nextName": "Simulator",
        "nextPath": "/device/simulator"
      }
    ],
    "id": "brainpad",
    "title": "GHI Brain Pad - Blocks / Javascript editor",
    "name": "GHI Brain Pad",
    "description": "A Blocks / JavaScript code editor for the GHI Brain Pad.",
    "logoCDN": "@cdnUrl@/blob/5882ba3bfdd0a1fec594ddd532a2365eb03f5844/static/logo.png",
    "docsLogoCDN": "@cdnUrl@/blob/badfd98507856473faf36c765ecd95f8faf754c5/static/logo.square.png",
    "portraitLogoCDN": "@cdnUrl@/blob/badfd98507856473faf36c765ecd95f8faf754c5/static/logo.square.png",
    "footerLogoCDN": "@cdnUrl@/blob/badfd98507856473faf36c765ecd95f8faf754c5/static/logo.square.png",
    "organizationLogoCDN": "@cdnUrl@/blob/f5f83b8c33d027642954f4f833432de810768249/static/Microsoft-logo_rgb_c-gray-square.png",
    "organizationWideLogoCDN": "@cdnUrl@/blob/e0a49fdb57be4b7e22d974e8e37171a47fa2fd0f/static/Microsoft-logo_rgb_c-white.png",
    "htmlDocIncludes": {}
  },
  "blocksprj": {
    "id": "blocksprj",
    "config": {
      "name": "{0}",
      "dependencies": {
        "brainpad": "*"
      },
      "description": "",
      "files": [
        "main.blocks",
        "main.ts",
        "README.md"
      ]
    },
    "files": {
      "README.md": "",
      "main.blocks": "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"forever\"></block>\n</xml>",
      "main.ts": "\n"
    }
  },
  "tsprj": {
    "id": "tsprj",
    "config": {
      "name": "{0}",
      "dependencies": {
        "brainpad": "*"
      },
      "description": "",
      "files": [
        "main.ts",
        "README.md"
      ]
    },
    "files": {
      "README.md": "",
      "main.ts": "\n"
    }
  },
  "bundledpkgs": {
    "base": {
      "README.md": "# base\n\nThe base library, shared by all C++ targets (not only Codal-based).\n\n\n",
      "buffer.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n\nusing namespace std;\n\n//% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\nnamespace BufferMethods {\n//%\nuint8_t *getBytes(Buffer buf) {\n    return buf->data;\n}\n\n//%\nint getByte(Buffer buf, int off) {\n    if (buf && 0 <= off && off < buf->length)\n        return buf->data[off];\n    return 0;\n}\n\n//%\nvoid setByte(Buffer buf, int off, int v) {\n    if (buf && 0 <= off && off < buf->length)\n        buf->data[off] = v;\n}\n\nint writeBuffer(Buffer buf, int dstOffset, Buffer src, int srcOffset = 0, int length = -1) {\n    if (length < 0)\n        length = src->length;\n\n    if (srcOffset < 0 || dstOffset < 0 || dstOffset > buf->length)\n        return -1;\n\n    length = min(src->length - srcOffset, buf->length - dstOffset);\n\n    if (length < 0)\n        return -1;\n\n    if (buf == src) {\n        memmove(buf->data + dstOffset, src->data + srcOffset, length);\n    } else {\n        memcpy(buf->data + dstOffset, src->data + srcOffset, length);\n    }\n\n    return 0;\n}\n\n/**\n * Write a number in specified format in the buffer.\n */\n//%\nvoid setNumber(Buffer buf, NumberFormat format, int offset, TNumber value) {\n    if (offset < 0)\n        return;\n    setNumberCore(buf->data + offset, buf->length - offset, format, value);\n}\n\n/**\n * Read a number in specified format from the buffer.\n */\n//%\nTNumber getNumber(Buffer buf, NumberFormat format, int offset) {\n    if (offset < 0)\n        return fromInt(0);\n    return getNumberCore(buf->data + offset, buf->length - offset, format);\n}\n\n/** Returns the length of a Buffer object. */\n//% property\nint length(Buffer s) {\n    return s->length;\n}\n\n/**\n * Fill (a fragment) of the buffer with given value.\n */\n//%\nvoid fill(Buffer buf, int value, int offset = 0, int length = -1) {\n    if (offset < 0 || offset > buf->length)\n        return; // DEVICE_INVALID_PARAMETER;\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    memset(buf->data + offset, value, length);\n}\n\n/**\n * Return a copy of a fragment of a buffer.\n */\n//%\nBuffer slice(Buffer buf, int offset = 0, int length = -1) {\n    offset = min((int)buf->length, offset);\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    return mkBuffer(buf->data + offset, length);\n}\n\n/**\n * Shift buffer left in place, with zero padding.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid shift(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n    if (offset <= -length || offset >= length) {\n        fill(buf, 0);\n        return;\n    }\n\n    uint8_t *data = buf->data + start;\n    if (offset < 0) {\n        offset = -offset;\n        memmove(data + offset, data, length - offset);\n        memset(data, 0, offset);\n    } else {\n        length = length - offset;\n        memmove(data, data + offset, length);\n        memset(data + length, 0, offset);\n    }\n}\n\n/**\n * Convert a buffer to its hexadecimal representation.\n */\n//%\nString toHex(Buffer buf) {\n    const char *hex = \"0123456789abcdef\";\n    auto res = mkString(NULL, buf->length * 2);\n    for (int i = 0; i < buf->length; ++i) {\n        res->data[i << 1] = hex[buf->data[i] >> 4];\n        res->data[(i << 1) + 1] = hex[buf->data[i] & 0xf];\n    }\n    return res;\n}\n\n/**\n * Rotate buffer left in place.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid rotate(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n\n    if (offset < 0)\n        offset += length << 8; // try to make it positive\n    offset %= length;\n    if (offset < 0)\n        offset += length;\n\n    uint8_t *data = buf->data + start;\n\n    uint8_t *n_first = data + offset;\n    uint8_t *first = data;\n    uint8_t *next = n_first;\n    uint8_t *last = data + length;\n\n    while (first != next) {\n        uint8_t tmp = *first;\n        *first++ = *next;\n        *next++ = tmp;\n        if (next == last) {\n            next = n_first;\n        } else if (first == n_first) {\n            n_first = next;\n        }\n    }\n}\n\n/**\n * Write contents of `src` at `dstOffset` in current buffer.\n */\n//%\nvoid write(Buffer buf, int dstOffset, Buffer src) {\n    // srcOff and length not supported, we only do up to 4 args :/\n    writeBuffer(buf, dstOffset, src, 0, -1);\n}\n}\n\nnamespace pxt {\nstatic int writeBytes(uint8_t *dst, uint8_t *src, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = dst + length;\n        for (int i = 0; i < length; ++i)\n            *--p = src[i];\n    } else {\n        if (length == 4 && ((uint32_t)dst & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uint32_t)dst & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nstatic int readBytes(uint8_t *src, uint8_t *dst, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        memset(dst, 0, length);\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = src + length;\n        for (int i = 0; i < length; ++i)\n            dst[i] = *--p;\n    } else {\n        if (length == 4 && ((uint32_t)src & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uint32_t)src & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nvoid setNumberCore(uint8_t *buf, int szLeft, NumberFormat format, TNumber value) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define WRITEBYTES(isz, swap, toInt)                                                               \\\n    isz = toInt(value);                                                                            \\\n    writeBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                   \\\n    break\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        WRITEBYTES(i8, false, toInt);\n    case NumberFormat::UInt8LE:\n        WRITEBYTES(u8, false, toInt);\n    case NumberFormat::Int16LE:\n        WRITEBYTES(i16, false, toInt);\n    case NumberFormat::UInt16LE:\n        WRITEBYTES(u16, false, toInt);\n    case NumberFormat::Int32LE:\n        WRITEBYTES(i32, false, toInt);\n    case NumberFormat::UInt32LE:\n        WRITEBYTES(u32, false, toUInt);\n\n    case NumberFormat::Int8BE:\n        WRITEBYTES(i8, true, toInt);\n    case NumberFormat::UInt8BE:\n        WRITEBYTES(u8, true, toInt);\n    case NumberFormat::Int16BE:\n        WRITEBYTES(i16, true, toInt);\n    case NumberFormat::UInt16BE:\n        WRITEBYTES(u16, true, toInt);\n    case NumberFormat::Int32BE:\n        WRITEBYTES(i32, true, toInt);\n    case NumberFormat::UInt32BE:\n        WRITEBYTES(u32, true, toUInt);\n\n    case NumberFormat::Float32LE:\n        WRITEBYTES(f32, false, toFloat);\n    case NumberFormat::Float32BE:\n        WRITEBYTES(f32, true, toFloat);\n    case NumberFormat::Float64LE:\n        WRITEBYTES(f64, false, toDouble);\n    case NumberFormat::Float64BE:\n        WRITEBYTES(f64, true, toDouble);\n    }\n}\n\nTNumber getNumberCore(uint8_t *buf, int szLeft, NumberFormat format) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define READBYTES(isz, swap, conv)                                                                 \\\n    readBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                    \\\n    return conv(isz)\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        READBYTES(i8, false, fromInt);\n    case NumberFormat::UInt8LE:\n        READBYTES(u8, false, fromInt);\n    case NumberFormat::Int16LE:\n        READBYTES(i16, false, fromInt);\n    case NumberFormat::UInt16LE:\n        READBYTES(u16, false, fromInt);\n    case NumberFormat::Int32LE:\n        READBYTES(i32, false, fromInt);\n    case NumberFormat::UInt32LE:\n        READBYTES(u32, false, fromUInt);\n\n    case NumberFormat::Int8BE:\n        READBYTES(i8, true, fromInt);\n    case NumberFormat::UInt8BE:\n        READBYTES(u8, true, fromInt);\n    case NumberFormat::Int16BE:\n        READBYTES(i16, true, fromInt);\n    case NumberFormat::UInt16BE:\n        READBYTES(u16, true, fromInt);\n    case NumberFormat::Int32BE:\n        READBYTES(i32, true, fromInt);\n    case NumberFormat::UInt32BE:\n        READBYTES(u32, true, fromUInt);\n\n    case NumberFormat::Float32LE:\n        READBYTES(f32, false, fromFloat);\n    case NumberFormat::Float32BE:\n        READBYTES(f32, true, fromFloat);\n    case NumberFormat::Float64LE:\n        READBYTES(f64, false, fromDouble);\n    case NumberFormat::Float64BE:\n        READBYTES(f64, true, fromDouble);\n    }\n\n    return 0;\n}\n}",
      "console.ts": "/// <reference no-default-lib=\"true\"/>\n\n/**\n * Reading and writing data to the console output.\n */\n//% weight=12 color=#002050 icon=\"\\uf120\"\n//% advanced=true\nnamespace console {\n    /**\n     * Write a line of text to the console output.\n     * @param value to send\n     */\n    //% weight=90\n    //% help=console/log blockGap=8\n    //% blockId=console_log block=\"console|log %text\"\n    export function log(text: string): void {\n        serial.writeString(text + \"\\r\\n\");\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the console output.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=console/log-value\n    //% blockId=console_log_value block=\"console|log value %name|= %value\"\n    export function logValue(name: string, value: number): void {\n        serial.writeValue(name, value);\n    }\n}",
      "control.cpp": "#include \"pxtbase.h\"\n\n\nnamespace control {\n    /**\n    * Gets the number of milliseconds elapsed since power on.\n    */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\"\n    int millis() {\n        return current_time_ms();\n    }\n\n    /**\n     * Run code when a registered event happens.\n     * @param id the event compoent id\n     * @param value the event value to match\n     */\n    //% weight=20 blockGap=8 blockId=\"control_on_event\" block=\"on event|from %src|with value %value\"\n    //% blockExternalInputs=1\n    //% help=\"control/on-event\"          \n    void onEvent(int src, int value, Action handler, int flags = 16) { // EVENT_LISTENER_DEFAULT_FLAGS\n        registerWithDal(src, value, handler, flags);\n    }\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\"\n    void reset() {\n        target_reset();\n    }\n\n    /**\n    * Block the current fiber for the given microseconds\n    * @param micros number of micro-seconds to wait. eg: 4\n    */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (s)%micros\"\n    void waitMicros(int micros) {\n        sleep_us(micros);\n    }\n\n    /**\n     * Run other code in the background.\n     */\n    //% help=control/run-in-background blockAllowMultiple=1 afterOnStart=true\n    //% blockId=\"control_run_in_background\" block=\"run in background\" blockGap=8\n    void runInBackground(Action a) {\n      pxt::runInBackground(a);\n    }\n\n    /**\n    * Blocks the calling thread until the specified event is raised.\n    */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\"\n    void waitForEvent(int src, int value) {\n        pxt::waitForEvent(src, value);\n    }\n\n    /**\n    * Derive a unique, consistent serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number\n    int deviceSerialNumber() {\n        return pxt::getSerialNumber();\n    }\n}\n",
      "control.ts": "/**\n* Program controls and events.\n*/\n//% weight=10 color=\"#31bca3\" icon=\"\\uf110\" advanced=true\nnamespace control {\n\n    /**\n     * Display an error code and stop the program.\n     * @param code an error number to display. eg: 5\n     */\n    //% help=control/panic weight=29\n    //% blockId=\"control_panic\" block=\"panic %code\"\n    //% shim=pxtrt::panic\n    export function panic(code: number) { }\n\n    /**\n     * Display an error code and stop the program when the assertion is `false`.\n     */\n    //% help=control/assert weight=30\n    //% blockId=\"control_assert\" block=\"assert %cond|with value %code\"\n    export function assert(cond: boolean, code: number) {\n        if (!cond) {\n            fail(\"Assertion failed, code=\" + code)\n        }\n    }\n\n    export function fail(message: string) {\n        serial.writeString(\"Fatal failure: \")\n        serial.writeString(message)\n        serial.writeString(\"\\r\\n\")\n        panic(108)\n    }\n\n    export class AnimationQueue {\n        running: boolean;\n        eventID: number;\n        public interval: number;\n\n        constructor() {\n            this.running = false;\n            this.eventID = control.allocateNotifyEvent();\n            this.interval = 1;\n        }\n\n        /**\n         * Runs 'render' in a loop until it returns false or the 'stop' function is called\n         */\n        runUntilDone(render: () => boolean) {\n            const evid = this.eventID;\n\n            // if other animation, wait for turn\n            if (this.running)\n                control.waitForEvent(DAL.DEVICE_ID_NOTIFY, evid);\n\n            // check if the animation hasn't been cancelled since we've waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // run animation\n            this.running = true;\n            while (this.running\n                && !this.isCancelled(evid)\n                && render()) {\n                loops.pause(this.interval);\n            }\n\n            // check if the animation hasn't been cancelled since we've been waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // we're done\n            this.running = false;\n            // unblock 1 fiber\n            control.raiseEvent(DAL.DEVICE_ID_NOTIFY_ONE, this.eventID);\n        }\n\n        isCancelled(evid: number) {\n            return this.eventID !== evid;\n        }\n\n        /**\n         * Cancels the current running animation and clears the queue\n         */\n        cancel() {\n            if (this.running) {\n                this.running = false;\n                const evid = this.eventID;\n                this.eventID = control.allocateNotifyEvent();\n                // unblock fibers\n                control.raiseEvent(DAL.DEVICE_ID_NOTIFY, evid);\n            }\n        }\n    }\n\n}\n\n\n/**\n * Tagged hex literal converter\n */\n//% shim=@hex\nfunction hex(lits: any, ...args: any[]): Buffer { return null }",
      "core.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nnamespace pxt {\n\nstatic HandlerBinding *handlerBindings;\n\nHandlerBinding *findBinding(int source, int value) {\n    for (auto p = handlerBindings; p; p = p->next) {\n        if (p->source == source && p->value == value) {\n            return p;\n        }\n    }\n    return 0;\n}\n\nvoid setBinding(int source, int value, Action act) {\n    auto curr = findBinding(source, value);\n    incr(act);\n    if (curr) {\n        decr(curr->action);\n        curr->action = act;\n        return;\n    }\n    curr = new HandlerBinding();\n    curr->next = handlerBindings;\n    curr->source = source;\n    curr->value = value;\n    curr->action = act;\n    handlerBindings = curr;\n}\n\nstatic const uint16_t emptyString[]\n    __attribute__((aligned(4))) = {0xffff, PXT_REF_TAG_STRING, 0, 0};\n\nstatic const uint16_t emptyBuffer[]\n    __attribute__((aligned(4))) = {0xffff, PXT_REF_TAG_BUFFER, 0, 0};\n\nString mkString(const char *data, int len) {\n    if (len < 0)\n        len = strlen(data);\n    if (len == 0)\n        return (String)emptyString;\n    String r = new (::operator new(sizeof(BoxedString) + len + 1)) BoxedString();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    r->data[len] = 0;\n    MEMDBG(\"mkString: len=%d => %p\", len, r);\n    return r;\n}\n\nBuffer mkBuffer(const uint8_t *data, int len) {\n    if (len <= 0)\n        return (Buffer)emptyBuffer;\n    Buffer r = new (::operator new(sizeof(BoxedBuffer) + len)) BoxedBuffer();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    else\n        memset(r->data, 0, len);\n    MEMDBG(\"mkBuffer: len=%d => %p\", len, r);\n    return r;\n}\n\nTNumber mkNaN() {\n    // TODO optimize\n    return fromDouble(NAN);\n}\n\nstatic unsigned random_value = 0xC0DA1;\n\nvoid seedRandom(unsigned seed) {\n    random_value = seed;\n}\n\nunsigned getRandom(unsigned max) {\n    unsigned m, result;\n\n    do {\n        m = (unsigned)max;\n        result = 0;\n\n        do {\n            // Cycle the LFSR (Linear Feedback Shift Register).\n            // We use an optimal sequence with a period of 2^32-1, as defined by Bruce Schneier here\n            // (a true legend in the field!),\n            // For those interested, it's documented in his paper:\n            // \"Pseudo-Random Sequence Generator for 32-Bit CPUs: A fast, machine-independent\n            // generator for 32-bit Microprocessors\"\n            // https://www.schneier.com/paper-pseudorandom-sequence.html\n            unsigned r = random_value;\n\n            r = ((((r >> 31) ^ (r >> 6) ^ (r >> 4) ^ (r >> 2) ^ (r >> 1) ^ r) & 1) << 31) |\n                (r >> 1);\n\n            random_value = r;   \n            \n            result = ((result << 1) | (r & 0x00000001));\n        } while (m >>= 1);\n    } while (result > (unsigned)max);\n\n    return result;\n}\n\nPXT_DEF_STRING(sTrue, \"true\")\nPXT_DEF_STRING(sFalse, \"false\")\nPXT_DEF_STRING(sUndefined, \"undefined\")\nPXT_DEF_STRING(sNull, \"null\")\nPXT_DEF_STRING(sObject, \"[Object]\")\nPXT_DEF_STRING(sFunction, \"[Function]\")\nPXT_DEF_STRING(sNaN, \"NaN\")\nPXT_DEF_STRING(sInf, \"Infinity\")\nPXT_DEF_STRING(sMInf, \"-Infinity\")\n}\n\nnamespace String_ {\n\n//%\nString mkEmpty() {\n    return mkString(\"\", 0);\n}\n\n//%\nString fromCharCode(int code) {\n    char buf[] = {(char)code, 0};\n    return mkString(buf, 1);\n}\n\n//%\nString charAt(String s, int pos) {\n    if (s && 0 <= pos && pos < s->length) {\n        return fromCharCode(s->data[pos]);\n    } else {\n        return mkEmpty();\n    }\n}\n\n//%\nTNumber charCodeAt(String s, int pos) {\n    if (s && 0 <= pos && pos < s->length) {\n        return fromInt(s->data[pos]);\n    } else {\n        return mkNaN();\n    }\n}\n\n//%\nString concat(String s, String other) {\n    if (!s)\n        s = (String)sNull;\n    if (!other)\n        other = (String)sNull;\n    if (s->length == 0)\n        return (String)incrRC(other);\n    if (other->length == 0)\n        return (String)incrRC(s);\n    String r = mkString(NULL, s->length + other->length);\n    memcpy(r->data, s->data, s->length);\n    memcpy(r->data + s->length, other->data, other->length);\n    return r;\n}\n\n//%\nint compare(String s, String that) {\n    if (s == that)\n        return 0;\n    // TODO this isn't quite right, in JS both `null < \"foo\"` and `null > \"foo\"` are false\n    if (!s)\n        return -1;\n    if (!that)\n        return 1;\n    int compareResult = strcmp(s->data, that->data);\n    if (compareResult < 0)\n        return -1;\n    else if (compareResult > 0)\n        return 1;\n    return 0;\n}\n\n//%\nint length(String s) {\n    return s->length;\n}\n\n//%\nTNumber toNumber(String s) {\n    // JSCHECK\n    char *endptr;\n    double v = strtod(s->data, &endptr);\n    if (endptr != s->data + s->length)\n        v = NAN;\n    else if (v == 0.0 || v == -0.0)\n        v = v;\n    else if (!isnormal(v))\n        v = NAN;\n    return fromDouble(v);\n}\n\n//%\nString substr(String s, int start, int length) {\n    if (length <= 0)\n        return mkEmpty();\n    if (start < 0)\n        start = max(s->length + start, 0);\n    length = min(length, s->length - start);\n    return mkString(s->data + start, length);\n}\n}\n\nnamespace Boolean_ {\n//%\nbool bang(int v) {\n    return v == 0;\n}\n}\n\nnamespace pxt {\n\n// ES5 9.5, 9.6\nunsigned toUInt(TNumber v) {\n    if (isNumber(v))\n        return numValue(v);\n    if (isSpecial(v)) {\n        if ((int)v >> 6)\n            return 1;\n        else\n            return 0;\n    }\n    if (!v)\n        return 0;\n\n    double num = toDouble(v);\n    if (!isnormal(num))\n        return 0;\n    double rem = fmod(trunc(num), 4294967296.0);\n    if (rem < 0.0)\n        rem += 4294967296.0;\n    return (unsigned)rem;\n}\nint toInt(TNumber v) {\n    return (int)toUInt(v);\n}\n\n// only support double in tagged mode\ndouble toDouble(TNumber v) {\n    if (isTagged(v))\n        return toInt(v);\n\n    // JSCHECK\n    ValType t = valType(v);\n    if (t == ValType::Number) {\n        BoxedNumber *p = (BoxedNumber *)v;\n        return p->num;\n    } else if (t == ValType::String) {\n        return toDouble(String_::toNumber((String)v));\n    } else {\n        return NAN;\n    }\n}\n\nfloat toFloat(TNumber v) {\n    // TODO optimize?\n    return (float)toDouble(v);\n}\n\nTNumber fromDouble(double r) {\n#ifndef PXT_BOX_DEBUG\n    int ri = ((int)r) << 1;\n    if ((ri >> 1) == r)\n        return (TNumber)(ri | 1);\n#endif\n    BoxedNumber *p = new BoxedNumber();\n    p->num = r;\n    MEMDBG(\"mkNum: %p\", p);\n    return (TNumber)p;\n}\n\nTNumber fromFloat(float r) {\n    // TODO optimize\n    return fromDouble(r);\n}\n\nTNumber fromInt(int v) {\n    if (canBeTagged(v))\n        return TAG_NUMBER(v);\n    return fromDouble(v);\n}\n\nTNumber fromUInt(unsigned v) {\n#ifndef PXT_BOX_DEBUG\n    if (v <= 0x3fffffff)\n        return TAG_NUMBER(v);\n#endif\n    return fromDouble(v);\n}\n\nTValue fromBool(bool v) {\n    if (v)\n        return TAG_TRUE;\n    else\n        return TAG_FALSE;\n}\n\nTNumber eqFixup(TNumber v) {\n    if (v == TAG_NULL)\n        return TAG_UNDEFINED;\n    if (v == TAG_TRUE)\n        return TAG_NUMBER(1);\n    if (v == TAG_FALSE)\n        return TAG_NUMBER(0);\n    return v;\n}\n\nbool eqq_bool(TValue a, TValue b) {\n    // TODO improve this\n\n    if (a == b)\n        return true;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta != tb)\n        return false;\n\n    if (ta == ValType::String)\n        return String_::compare((String)a, (String)b) == 0;\n\n    int aa = (int)a;\n    int bb = (int)b;\n\n    // if at least one of the values is tagged, they are not equal\n    if ((aa | bb) & 3)\n        return false;\n\n    if (ta == ValType::Number)\n        return toDouble(a) == toDouble(b);\n    else\n        return a == b;\n}\n\nbool eq_bool(TValue a, TValue b) {\n    return eqq_bool(eqFixup(a), eqFixup(b));\n}\n\n//%\nbool switch_eq(TValue a, TValue b) {\n    if (eqq_bool(eqFixup(a), eqFixup(b))) {\n        decr(b);\n        return true;\n    }\n    return false;\n}\n\n}\n\nnamespace langsupp {\n//%\nTValue ptreq(TValue a, TValue b) {\n    return eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTValue ptreqq(TValue a, TValue b) {\n    return eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTValue ptrneq(TValue a, TValue b) {\n    return !eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTValue ptrneqq(TValue a, TValue b) {\n    return !eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n}\n\n#define NUMOP(op) return fromDouble(toDouble(a) op toDouble(b));\n#define BITOP(op) return fromInt(toInt(a) op toInt(b));\nnamespace numops {\n\n//%\nint toBool(TValue v) {\n    if (isTagged(v)) {\n        if (v == TAG_UNDEFINED || v == TAG_NULL || v == TAG_FALSE || v == TAG_NUMBER(0))\n            return 0;\n        else\n            return 1;\n    }\n\n    ValType t = valType(v);\n    if (t == ValType::String) {\n        String s = (String)v;\n        if (s->length == 0)\n            return 0;\n    } else if (t == ValType::Number) {\n        double x = toDouble(v);\n        if (isnan(x) || x == 0.0 || x == -0.0)\n            return 0;\n        else\n            return 1;\n    }\n\n    return 1;\n}\n\n//%\nint toBoolDecr(TValue v) {\n    if (v == TAG_TRUE)\n        return 1;\n    if (v == TAG_FALSE)\n        return 0;\n    int r = toBool(v);\n    decr(v);\n    return r;\n}\n\n// TODO\n// The integer, non-overflow case for add/sub/bit opts is handled in assembly\n\n//%\nTNumber adds(TNumber a, TNumber b){NUMOP(+)}\n\n//%\nTNumber subs(TNumber a, TNumber b){NUMOP(-)}\n\n//%\nTNumber muls(TNumber a, TNumber b) {\n    if (bothNumbers(a, b)) {\n        int aa = (int)a;\n        int bb = (int)b;\n        // if both operands fit 15 bits, the result will not overflow int\n        if ((aa >> 15 == 0 || aa >> 15 == -1) && (bb >> 15 == 0 || bb >> 15 == -1)) {\n            // it may overflow 31 bit int though - use fromInt to convert properly\n            return fromInt((aa >> 1) * (bb >> 1));\n        }\n    }\n    NUMOP(*)\n}\n\n//%\nTNumber div(TNumber a, TNumber b){NUMOP(/)}\n\n//%\nTNumber mod(TNumber a, TNumber b) {\n    if (isNumber(a) && isNumber(b) && numValue(b))\n        BITOP(%)\n    return fromDouble(fmod(toDouble(a), toDouble(b)));\n}\n\n//%\nTNumber lsls(TNumber a, TNumber b){BITOP(<<)}\n\n//%\nTNumber lsrs(TNumber a, TNumber b) {\n    return fromUInt(toUInt(a) >> toUInt(b));\n}\n\n//%\nTNumber asrs(TNumber a, TNumber b){BITOP(>>)}\n\n//%\nTNumber eors(TNumber a, TNumber b){BITOP (^)}\n\n//%\nTNumber orrs(TNumber a, TNumber b){BITOP(|)}\n\n//%\nTNumber ands(TNumber a, TNumber b) {\n    BITOP(&)\n}\n\n#define CMPOP_RAW(op)                                                                              \\\n    if (bothNumbers(a, b))                                                                         \\\n        return (int)a op((int)b);                                                                  \\\n    return toDouble(a) op toDouble(b);\n\n#define CMPOP(op)                                                                                  \\\n    if (bothNumbers(a, b))                                                                         \\\n        return ((int)a op((int)b)) ? TAG_TRUE : TAG_FALSE;                                         \\\n    return toDouble(a) op toDouble(b) ? TAG_TRUE : TAG_FALSE;\n\n//%\nbool lt_bool(TNumber a, TNumber b){CMPOP_RAW(<)}\n\n//%\nTNumber le(TNumber a, TNumber b){CMPOP(<=)}\n\n//%\nTNumber lt(TNumber a, TNumber b){CMPOP(<)}\n\n//%\nTNumber ge(TNumber a, TNumber b){CMPOP(>=)}\n\n//%\nTNumber gt(TNumber a, TNumber b){CMPOP(>)}\n\n//%\nTNumber eq(TNumber a, TNumber b) {\n    return pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neq(TNumber a, TNumber b) {\n    return !pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber eqq(TNumber a, TNumber b) {\n    return pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neqq(TNumber a, TNumber b) {\n    return !pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\nasm(\".global _printf_float\");\nextern \"C\" char *gcvt(double d, int ndigit, char *buf);\n\n//%\nString toString(TValue v) {\n\n    if (v == TAG_UNDEFINED)\n        return (String)(void *)sUndefined;\n    else if (v == TAG_FALSE)\n        return (String)(void *)sFalse;\n    else if (v == TAG_TRUE)\n        return (String)(void *)sTrue;\n    else if (v == TAG_NULL)\n        return (String)(void *)sNull;\n    ValType t = valType(v);\n\n    if (t == ValType::String) {\n        return (String)(void *)incr(v);\n    } else if (t == ValType::Number) {\n        char buf[64];\n\n        // if (isNumber(v)) {\n        //    int x = numValue(v);\n        //    itoa(x, buf);\n        //} else {\n        double x = toDouble(v);\n\n        if (isnan(x))\n            return (String)(void *)sNaN;\n        if (isinf(x)) {\n            if (x < 0)\n                return (String)(void *)sMInf;\n            else\n                return (String)(void *)sInf;\n        }\n        gcvt(x, 16, buf);\n        //}\n\n        return mkString(buf);\n    } else if (t == ValType::Function) {\n        return (String)(void *)sFunction;\n    } else {\n        return (String)(void *)sObject;\n    }\n}\n}\n\nnamespace Math_ {\n//%\nTNumber pow(TNumber x, TNumber y) {\n    return fromDouble(::pow(toDouble(x), toDouble(y)));\n}\n\n//%\nTNumber atan2(TNumber y, TNumber x) {\n    return fromDouble(::atan2(toDouble(y), toDouble(y)));\n}\n\ndouble randomDouble() {\n    return getRandom(UINT_MAX) / ((double)UINT_MAX + 1) +\n           getRandom(0xffffff) / ((double)UINT_MAX * 0xffffff);\n}\n\n//%\nTNumber random() {\n    return fromDouble(randomDouble());\n}\n\n//%\nTNumber randomRange(TNumber min, TNumber max) {\n    if (isNumber(min) && isNumber(max)) {\n        int mini = numValue(min);\n        int maxi = numValue(max);\n        if (mini > maxi) {\n            int temp = mini;\n            mini = maxi;\n            maxi = temp;\n        }\n        if (maxi == mini)\n            return fromInt(mini);\n        else\n            return fromInt(mini + getRandom(maxi - mini));\n    } else {\n        double mind = toDouble(min);\n        double maxd = toDouble(max);\n        if (mind > maxd) {\n            double temp = mind;\n            mind = maxd;\n            maxd = temp;\n        }\n        if (maxd == mind)\n            return fromDouble(mind);\n        else {\n            return fromDouble(mind + randomDouble() * (maxd - mind));\n        }\n    }\n}\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber log(TNumber x){SINGLE(log)}\n\n//%\nTNumber exp(TNumber x){SINGLE(exp)}\n\n//%\nTNumber tan(TNumber x){SINGLE(tan)}\n\n//%\nTNumber sin(TNumber x){SINGLE(sin)}\n\n//%\nTNumber cos(TNumber x){SINGLE(cos)}\n\n//%\nTNumber atan(TNumber x){SINGLE(atan)}\n\n//%\nTNumber asin(TNumber x){SINGLE(asin)}\n\n//%\nTNumber acos(TNumber x){SINGLE(acos)}\n\n//%\nTNumber sqrt(TNumber x){SINGLE(sqrt)}\n\n//%\nTNumber floor(TNumber x){SINGLE(floor)}\n\n//%\nTNumber ceil(TNumber x){SINGLE(ceil)}\n\n//%\nTNumber trunc(TNumber x){SINGLE(trunc)}\n\n//%\nTNumber round(TNumber x) {\n    SINGLE(round)\n}\n\n//%\nint imul(int x, int y) {\n    return x * y;\n}\n\n//%\nint idiv(int x, int y) {\n    return x / y;\n}\n}\n\nnamespace Array_ {\n//%\nRefCollection *mk(unsigned flags) {\n    auto r = new RefCollection();\n    MEMDBG(\"mkColl: %p\", r);\n    return r;\n}\n//%\nint length(RefCollection *c) {\n    return c->length();\n}\n//%\nvoid setLength(RefCollection *c, int newLength) {\n    c->setLength(newLength);\n}\n//%\nvoid push(RefCollection *c, TValue x) {\n    c->push(x);\n}\n//%\nTValue pop(RefCollection *c) {\n    return c->pop();\n}\n//%\nTValue getAt(RefCollection *c, int x) {\n    return c->getAt(x);\n}\n//%\nvoid setAt(RefCollection *c, int x, TValue y) {\n    c->setAt(x, y);\n}\n//%\nTValue removeAt(RefCollection *c, int x) {\n    return c->removeAt(x);\n}\n//%\nvoid insertAt(RefCollection *c, int x, TValue value) {\n    c->insertAt(x, value);\n}\n//%\nint indexOf(RefCollection *c, TValue x, int start) {\n    return c->indexOf(x, start);\n}\n//%\nbool removeElement(RefCollection *c, TValue x) {\n    return c->removeElement(x);\n}\n}\n\nnamespace pxt {\n//%\nvoid *ptrOfLiteral(int offset);\n\n//%\nunsigned programSize() {\n    return bytecode[17] * 2;\n}\n\n//%\nint getConfig(int key, int defl) {\n    int *cfgData = *(int**)&bytecode[18];\n    for (int i = 0;; i += 2) {\n        if (cfgData[i] == key) return cfgData[i + 1];\n        if (cfgData[i] == 0) return defl;\n    }\n}\n\n}\n\nnamespace pxtrt {\n//%\nTValue ldloc(RefLocal *r) {\n    return r->v;\n}\n\n//%\nTValue ldlocRef(RefRefLocal *r) {\n    TValue tmp = r->v;\n    incr(tmp);\n    return tmp;\n}\n\n//%\nvoid stloc(RefLocal *r, TValue v) {\n    r->v = v;\n}\n\n//%\nvoid stlocRef(RefRefLocal *r, TValue v) {\n    decr(r->v);\n    r->v = v;\n}\n\n//%\nRefLocal *mkloc() {\n    auto r = new RefLocal();\n    MEMDBG(\"mkloc: %p\", r);\n    return r;\n}\n\n//%\nRefRefLocal *mklocRef() {\n    auto r = new RefRefLocal();\n    MEMDBG(\"mklocRef: %p\", r);\n    return r;\n}\n\n// All of the functions below unref() self. This is for performance reasons -\n// the code emitter will not emit the unrefs for them.\n\n//%\nTValue ldfld(RefRecord *r, int idx) {\n    TValue tmp = r->ld(idx);\n    r->unref();\n    return tmp;\n}\n\n//%\nTValue ldfldRef(RefRecord *r, int idx) {\n    TValue tmp = r->ldref(idx);\n    r->unref();\n    return tmp;\n}\n\n//%\nvoid stfld(RefRecord *r, int idx, TValue val) {\n    r->st(idx, val);\n    r->unref();\n}\n\n//%\nvoid stfldRef(RefRecord *r, int idx, TValue val) {\n    r->stref(idx, val);\n    r->unref();\n}\n\n// Store a captured local in a closure. It returns the action, so it can be chained.\n//%\nRefAction *stclo(RefAction *a, int idx, TValue v) {\n    // DBG(\"STCLO \"); a->print(); DBG(\"@%d = %p\\n\", idx, (void*)v);\n    a->stCore(idx, v);\n    return a;\n}\n\n//%\nvoid panic(int code) {\n    target_panic(code);\n}\n\n//%\nString emptyToNull(String s) {\n    if (!s || s->length == 0)\n        return NULL;\n    return s;\n}\n\n//%\nint ptrToBool(TValue p) {\n    if (p) {\n        decr(p);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n//%\nRefMap *mkMap() {\n    auto r = new RefMap();\n    MEMDBG(\"mkMap: %p\", r);\n    return r;\n}\n\n//%\nTValue mapGet(RefMap *map, unsigned key) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        map->unref();\n        return 0;\n    }\n    TValue r = incr(map->values.get(i));\n    map->unref();\n    return r;\n}\n\n//%\nTValue mapGetRef(RefMap *map, unsigned key) {\n    return mapGet(map, key);\n}\n\n//%\nvoid mapSet(RefMap *map, unsigned key, TValue val) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        map->keys.push((TValue)key);\n        map->values.push(val);\n    } else {\n        map->values.setRef(i, val);\n    }\n    map->unref();\n}\n\n//%\nvoid mapSetRef(RefMap *map, unsigned key, TValue val) {\n    mapSet(map, key, val);\n}\n\n//\n// Debugger\n//\n\n// This is only to be called once at the beginning of lambda function\n//%\nvoid *getGlobalsPtr() {\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    return globals;\n}\n\n//%\nvoid runtimeWarning(String s) {\n    // noop for now\n}\n}\n\nnamespace pxt {\n\n//%\nValType valType(TValue v) {\n    if (isTagged(v)) {\n        if (!v)\n            return ValType::Undefined;\n\n        if (isNumber(v))\n            return ValType::Number;\n        if (v == TAG_TRUE || v == TAG_FALSE)\n            return ValType::Boolean;\n        else if (v == TAG_NULL)\n            return ValType::Object;\n        else {\n            oops();\n            return ValType::Object;\n        }\n    } else {\n        int tag = ((RefObject *)v)->vtable;\n\n        if (tag == PXT_REF_TAG_STRING)\n            return ValType::String;\n        else if (tag == PXT_REF_TAG_NUMBER)\n            return ValType::Number;\n        else if (tag == PXT_REF_TAG_ACTION || getVTable((RefObject *)v) == &RefAction_vtable)\n            return ValType::Function;\n\n        return ValType::Object;\n    }\n}\n\nPXT_DEF_STRING(sObjectTp, \"object\")\nPXT_DEF_STRING(sBooleanTp, \"boolean\")\nPXT_DEF_STRING(sStringTp, \"string\")\nPXT_DEF_STRING(sNumberTp, \"number\")\nPXT_DEF_STRING(sFunctionTp, \"function\")\nPXT_DEF_STRING(sUndefinedTp, \"undefined\")\n\n//%\nString typeOf(TValue v) {\n    switch (valType(v)) {\n    case ValType::Undefined:\n        return (String)sUndefinedTp;\n    case ValType::Boolean:\n        return (String)sBooleanTp;\n    case ValType::Number:\n        return (String)sNumberTp;\n    case ValType::String:\n        return (String)sStringTp;\n    case ValType::Object:\n        return (String)sObjectTp;\n    case ValType::Function:\n        return (String)sFunctionTp;\n    default:\n        oops();\n        return 0;\n    }\n}\n\n// Maybe in future we will want separate print methods; for now ignore\nvoid anyPrint(TValue v) {\n    if (valType(v) == ValType::Object) {\n        if (isRefCounted(v)) {\n            auto o = (RefObject *)v;\n            auto meth = ((RefObjectMethod)getVTable(o)->methods[1]);\n            if ((void *)meth == (void *)&anyPrint)\n                DMESG(\"[RefObject refs=%d vt=%p]\", o->refcnt, o->vtable);\n            else\n                meth(o);\n        } else {\n            DMESG(\"[Native %p]\", v);\n        }\n    } else {\n        String s = numops::toString(v);\n        DMESG(\"[%s %p = %s]\", pxt::typeOf(v)->data, v, s->data);\n        decr((TValue)s);\n    }\n}\n\nvoid dtorDoNothing() {}\n\n#define PRIM_VTABLE(name, sz)                                                                      \\\n    const VTable name = {sz,                                                                       \\\n                         0,                                                                        \\\n                         0,                                                                        \\\n                         {                                                                         \\\n                             (void *)&dtorDoNothing, (void *)&anyPrint,                            \\\n                         }};\nPRIM_VTABLE(string_vt, 0)\nPRIM_VTABLE(image_vt, 0)\nPRIM_VTABLE(buffer_vt, 0)\nPRIM_VTABLE(number_vt, 12)\nPRIM_VTABLE(action_vt, 0)\n\nstatic const VTable *primVtables[] = {0,          // 0\n                                      &string_vt, // 1\n                                      &buffer_vt, // 2\n                                      &image_vt,  // 3\n                                      // filler:\n                                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                                      0, 0, 0, 0, 0, 0, 0,\n                                      &number_vt, // 32\n                                      &action_vt, // 33\n                                      0};\n\nVTable *getVTable(RefObject *r) {\n    if (r->vtable >= 34)\n        return (VTable *)(r->vtable << vtableShift);\n    if (r->vtable == 0)\n        target_panic(100);\n    return (VTable *)primVtables[r->vtable];\n}\n}\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum NumberFormat {\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    }\n\n\n    declare const enum ValType {\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "loops.cpp": "#include \"pxtbase.h\"\n\nnamespace loops {\n\n/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true\n//% blockId=forever block=\"forever\" blockAllowMultiple=1\nvoid forever(Action a) {\n    runForever(a);\n}\n\n/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause\nvoid pause(int ms) {\n    sleep_ms(ms);\n}\n\n}",
      "loops.ts": "namespace loops {\n    class PollEvent {\n        public eid: number;\n        public vid: number;\n        public start: number;\n        public timeOut: number;\n        public condition: () => boolean;\n        public once: boolean;\n        constructor(eid: number, vid: number, start: number, timeOut: number, condition: () => boolean, once: boolean) {\n            this.eid = eid;\n            this.vid = vid;\n            this.start = start;\n            this.timeOut = timeOut;\n            this.condition = condition;\n            this.once = once;\n        }\n    }\n\n    let _pollEventQueue: PollEvent[] = undefined;\n\n    function pollEvents() {\n        while (_pollEventQueue.length > 0) {\n            const now = control.millis();\n            for (let i = 0; i < _pollEventQueue.length; ++i) {\n                const ev = _pollEventQueue[i];\n                if (ev.condition() || (ev.timeOut > 0 && now - ev.start > ev.timeOut)) {\n                    control.raiseEvent(ev.eid, ev.vid);\n                    if (ev.once) {\n                        _pollEventQueue.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            loops.pause(50);\n        }\n        // release fiber\n        _pollEventQueue = undefined;\n    }\n\n    function queuePollEvent(timeOut: number, condition: () => boolean, handler: () => void) {\n        const ev = new PollEvent(\n            control.allocateNotifyEvent(),\n            1,\n            control.millis(),\n            timeOut,\n            condition,\n            !handler\n        );\n\n        // start polling fiber if needed\n        if (!_pollEventQueue) {\n            _pollEventQueue = [ev];\n            control.runInBackground(pollEvents);\n        }\n        else {\n            // add to the queue\n            _pollEventQueue.push(ev)\n        }\n\n        // register event\n        if (handler)\n            control.onEvent(ev.eid, ev.vid, handler);\n        else // or wait\n            control.waitForEvent(ev.eid, ev.vid);\n    }\n\n    /**\n     * Busy wait for a condition to be true\n     * @param condition condition to test for\n     * @param timeOut if positive, maximum duration to wait for in milliseconds\n     */\n    //% \n    export function waitUntil(condition: () => boolean, timeOut?: number): void {\n        if (!condition || condition()) return; // optimistic path\n        if (!timeOut) timeOut = 0;\n        queuePollEvent(timeOut, condition, undefined);\n    }\n}",
      "math.ts": "namespace Math {    \n    /**\n     * Re-maps a number from one range to another. That is, a value of ``from low`` would get mapped to ``to low``, a value of ``from high`` to ``to high``, values in-between to values in-between, etc.\n     * @param value value to map in ranges\n     * @param fromLow the lower bound of the value's current range\n     * @param fromHigh the upper bound of the value's current range, eg: 1023\n     * @param toLow the lower bound of the value's target range\n     * @param toHigh the upper bound of the value's target range, eg: 4\n     */\n    //% help=math/map weight=10 blockGap=8\n    //% blockId=math_map block=\"map %value|from low %fromLow|from high %fromHigh|to low %toLow|to high %toHigh\"\n    export function map(value: number, fromLow: number, fromHigh: number, toLow: number, toHigh: number): number {\n        return ((value - fromLow) * (toHigh - toLow)) / (fromHigh - fromLow) + toLow;\n    }    \n\n    /**\n     * Constrains a number to be within a range\n     * @param x the number to constrain, all data types\n     * @param y the lower end of the range, all data types\n     * @param z the upper end of the range, all data types\n     */\n    //% help=math/constrain weight=11 blockGap=8\n    //% blockId=\"math_constrain_value\" block=\"constrain %value|between %low|and %high\"\n    export function constrain(value: number, low: number, high: number): number {\n        return value < low ? low : value > high ? high : value;\n    }\n\n    const b_m16: number[] = [0, 49, 49, 41, 90, 27, 117, 10]\n    /**\n     * Returns the sine of an input angle. This is an 8-bit approximation.\n     * @param theta input angle from 0-255\n     */\n    //% help=math/isin weight=11 advanced=true blockGap=8\n    export function isin(theta: number) {\n        //reference: based on FASTLed's sin approximation method: [https://github.com/FastLED/FastLED](MIT)\n        let offset = theta;\n        if( theta & 0x40 ) {\n            offset = 255 - offset;\n        }\n        offset &= 0x3F; // 0..63\n\n        let secoffset  = offset & 0x0F; // 0..15\n        if( theta & 0x40) secoffset++;\n\n        let section = offset >> 4; // 0..3\n        let s2 = section * 2;\n\n        let b = b_m16[s2];\n        let m16 = b_m16[s2+1];\n        let mx = (m16 * secoffset) >> 4;\n        \n        let y = mx + b;\n        if( theta & 0x80 ) y = -y;\n\n        y += 128;\n\n        return y;\n    }\n\n    /**\n     * Returns the cosine of an input angle. This is an 8-bit approximation. \n     * @param theta input angle from 0-255\n     */\n    //% help=math/icos weight=10 advanced=true blockGap=8\n    export function icos(theta: number) {\n        return isin(theta + 16384);\n    }\n}",
      "ns.ts": "\n/**\n * Respond to and read data from buttons and sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}\n\nnamespace loops {\n    /**\n      * Get the time field editor\n      * @param ms time duration in milliseconds, eg: 500, 1000\n      */\n    //% blockId=timePicker block=\"%ms\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% ms.fieldEditor=\"numberdropdown\" ms.fieldOptions.decompileLiterals=true\n    //% ms.fieldOptions.data='[[\"100 ms\", 100], [\"200 ms\", 200], [\"500 ms\", 500], [\"1 second\", 1000], [\"2 seconds\", 2000]]'\n    export function timePicker(ms: number): number{\n        return ms;\n    }\n}\n",
      "pxt-core.d.ts": "/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n      * Get or set the length of an array. This number is one more than the index of the last element the array.\n      */\n    //% shim=Array_::length weight=84\n    //% blockId=\"lists_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"arrays\"\n    length: number;\n\n    /**\n      * Append a new element to an array.\n      * @param items New elements of the Array.\n      */\n    //% help=arrays/push\n    //% shim=Array_::push weight=49\n    //% blockId=\"array_push\" block=\"%list| add value %value| to end\" blockNamespace=\"arrays\"\n    push(item: T): void;\n\n    /**\n      * Remove the last element from an array and return it.\n      */\n    //% help=arrays/pop\n    //% shim=Array_::pop weight=48\n    //% blockId=\"array_pop\" block=\"get and remove last value from %list\" blockNamespace=\"arrays\"\n    pop(): T;\n\n    /**\n      * Reverse the elements in an array. The first array element becomes the last, and the last array element becomes the first.\n      */\n    //% help=arrays/reverse\n    //% helper=arrayReverse weight=10\n    //% blockId=\"array_reverse\" block=\"reverse %list\" blockNamespace=\"arrays\"\n    reverse(): void;\n\n    /**\n      * Remove the first element from an array and return it. This method changes the length of the array.\n      */\n    //% help=arrays/shift\n    //% helper=arrayShift weight=70\n    //% blockId=\"array_shift\" block=\"get and remove first value from %list\" blockNamespace=\"arrays\"\n    shift(): T;\n\n    /**\n      * Add one element to the beginning of an array and return the new length of the array.\n      * @param element to insert at the start of the Array.\n      */\n    //% help=arrays/unshift\n    //% helper=arrayUnshift weight=69\n    //% blockId=\"array_unshift\" block=\"%list| insert %value| at beginning\" blockNamespace=\"arrays\"\n    //unshift(...values:T[]): number; //rest is not supported in our compiler yet.\n    unshift(value: T): number;\n\n    /**\n      * Return a section of an array.\n      * @param start The beginning of the specified portion of the array. eg: 0\n      * @param end The end of the specified portion of the array. eg: 0\n      */\n    //% help=arrays/slice\n    //% helper=arraySlice weight=41 blockNamespace=\"arrays\"\n    slice(start: number, end: number): T[];\n\n    /**\n      * Remove elements from an array.\n      * @param start The zero-based location in the array from which to start removing elements. eg: 0\n      * @param deleteCount The number of elements to remove. eg: 0\n      */\n    //% helper=arraySplice weight=40\n    splice(start: number, deleteCount: number): void;\n\n    /**\n      * Sort the elements of an array in place and returns the array. The sort is not necessarily stable.\n      * @param specifies a function that defines the sort order. If omitted, the array is sorted according to the prmitive type\n      */\n    //% helper=arraySort weight=40\n    sort(callbackfn?: (value1: T, value2: T) => number): T[];\n\n    /**\n      * Call a defined callback function on each element of an array, and return an array containing the results.\n      * @param callbackfn A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayMap weight=40\n    map<U>(callbackfn: (value: T, index: number) => U): U[];\n\n    /**\n      * Return the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayFilter weight=40\n    filter(callbackfn: (value: T, index: number) => boolean): T[];\n\n    /**\n      * Call the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    //% helper=arrayReduce weight=40\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U;\n\n\n    /** Remove the first occurence of an object. Returns true if removed. */\n    //% shim=Array_::removeElement weight=48\n    removeElement(element: T): boolean;\n\n    /** Remove the element at a certain index. */\n    //% help=arrays/remove-at\n    //% shim=Array_::removeAt weight=49\n    //% blockId=\"array_removeat\" block=\"%list| remove value at %index\" blockNamespace=\"arrays\"\n    removeAt(index: number): T;\n\n    /**\n     * Insert the value at a particular index, increases length by 1\n     * @param index the zero-based position in the list to insert the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/insert-at\n    //% shim=Array_::insertAt weight=84\n    //% blockId=\"array_insertAt\" block=\"%list| insert at %index| value %value\" blockNamespace=\"arrays\"\n    insertAt(index: number, value: T): void;\n\n    /**\n      * Return the index of the first occurrence of a value in an array.\n      * @param item The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    //% help=arrays/index-of\n    //% shim=Array_::indexOf weight=50\n    //% blockId=\"array_indexof\" block=\"%list| find index of %value\" blockNamespace=\"arrays\"\n    indexOf(item: T, fromIndex?: number): number;\n\n    /**\n     * Get the value at a particular index\n     * @param index the zero-based position in the list of the item, eg: 0\n     */\n    //% help=arrays/get\n    //% shim=Array_::getAt weight=85\n    get(index: number): T;\n\n    /**\n     * Store a value at a particular index\n     * @param index the zero-based position in the list to store the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/set\n    //% shim=Array_::setAt weight=84\n    set(index: number, value: T): void;\n\n    [n: number]: T;\n}\n\ndeclare interface String {\n    // This block is currently disabled in favor of the built-in Blockly \"Create text with\" block, which compiles to \"\" + \"\"\n    // Add % sign back to the block annotation to re-enable\n    /**\n     * Returns a string that contains the concatenation of two or more strings.\n     * @param other The string to append to the end of the string.\n     */\n    //% shim=String_::concat weight=49\n    //% blockId=\"string_concat\" blockNamespace=\"text\"\n    // block=\"join %list=text|%other\"\n    concat(other: string): string;\n\n    /**\n     * Return the character at the specified index.\n     * @param index The zero-based index of the desired character.\n     */\n    //% shim=String_::charAt weight=48\n    //% help=text/char-at\n    //% blockId=\"string_get\" block=\"char from %this=text|at %pos\" blockNamespace=\"text\"\n    charAt(index: number): string;\n\n    /** Returns the length of a String object. */\n    //% property shim=String_::length weight=47\n    //% blockId=\"text_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"text\"\n    length: number;\n\n    /**\n     * Return the Unicode value of the character at the specified location.\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n     */\n    //% shim=String_::charCodeAt\n    charCodeAt(index: number): number;\n\n    /**\n     * See how the order of characters in two strings is different (in ASCII encoding).\n     * @param that String to compare to target string\n     */\n    //% shim=String_::compare\n    //% help=text/compare\n    //% blockId=\"string_compare\" block=\"compare %this=text| to %that\" blockNamespace=\"text\"\n    compare(that: string): number;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param length number of characters to extract\n     */\n    //% shim=String_::substr length.defl=10\n    //% help=text/substr\n    //% blockId=\"string_substr\" block=\"substring of %this=text|from %start|of length %length\" blockNamespace=\"text\"\n    substr(start: number, length?: number): string;\n\n    // This block is currently disabled, as it does not compile in some targets\n    // Add % sign back to the block annotation to re-enable\n    /** Returns a value indicating if the string is empty */\n    //% shim=String_::isEmpty\n    //% blockId=\"string_isempty\" blockNamespace=\"text\"\n    // block=\"%this=text| is empty\"\n    isEmpty(): boolean;\n\n    [index: number]: string;\n}\n\n/**\n  * Convert a string to an integer.\n  * @param s A string to convert into a number. eg: 123\n  */\n//% shim=String_::toNumber\n//% help=text/parse-int\n//% blockId=\"string_parseint\" block=\"parse to integer %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\ndeclare function parseInt(text: string): number;\n\ninterface Object { }\ninterface Function { }\ninterface IArguments { }\ninterface RegExp { }\n\ntype uint8 = number;\ntype uint16 = number;\ntype uint32 = number;\ntype int8 = number;\ntype int16 = number;\ntype int32 = number;\n\n\ndeclare interface Boolean {\n    /**\n     * Returns a string representation of an object.\n     */\n    //% shim=Boolean_::toString\n    toString(): string;\n}\n\n/**\n * Combine, split, and search text strings.\n*/\n//% blockNamespace=\"Text\"\ndeclare namespace String {\n\n    /**\n     * Make a string from the given ASCII character code.\n     */\n    //% help=math/from-char-code\n    //% shim=String_::fromCharCode\n    //% weight=0\n    //% blockNamespace=\"Text\" blockId=\"stringFromCharCode\" block=\"text from char code %code\" weight=1\n    function fromCharCode(code: number): string;\n}\n\ndeclare interface Number {\n    /**\n     * Returns a string representation of a number.\n     */\n    //% shim=Number_::toString\n    toString(): string;\n}\n\n/**\n * Add, remove, and replace items in lists.\n*/\n//% blockNamespace=\"Arrays\"\ndeclare namespace Array {\n}\n\n/**\n * More complex operations with numbers.\n*/\ndeclare namespace Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    //% shim=Math_::pow\n    function pow(x: number, y: number): number;\n\n    /**\n     * Returns a pseudorandom number between 0 and 1.\n     */\n    //% shim=Math_::random\n    //% helpUrl=\"/reference/math/random\"\n    function random(): number;\n\n    /**\n     * Returns a pseudorandom number between min and max included. \n     * If both numbers are integral, the result is integral.\n     * @param min the lower inclusive bound, eg: 0\n     * @param max the upper inclusive bound, eg: 10\n     */\n    //% blockId=\"device_random\" block=\"pick random %min|to %limit\"\n    //% helpUrl=\"/reference/math/random-range\"\n    //% shim=Math_::randomRange\n    function randomRange(min: number, max: number): number;\n\n    /**\n     * Returns the natural logarithm (base e) of a number.\n     * @param x A number\n     */\n    //% shim=Math_::log\n    function log(x: number): number;\n\n    /**\n     * Returns returns ``e^x``.\n     * @param x A number\n     */\n    //% shim=Math_::exp\n    function exp(x: number): number;\n\n    /**\n     * Returns the sine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::sin\n    function sin(x: number): number;\n\n    /**\n     * Returns the cosine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::cos\n    function cos(x: number): number;\n\n    /**\n     * Returns the tangent of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::tan\n    function tan(x: number): number;\n\n    /**\n     * Returns the arcsine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::asin\n    function asin(x: number): number;\n\n    /**\n     * Returns the arccosine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::acos\n    function acos(x: number): number;\n\n    /**\n     * Returns the arctangent (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::atan\n    function atan(x: number): number;\n\n    /**\n     * Returns the arctangent of the quotient of its arguments.\n     * @param y A number\n     * @param x A number\n     */\n    //% shim=Math_::atan2\n    function atan2(y: number, x: number): number;\n\n    /**\n     * Returns the square root of a number.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::sqrt\n    function sqrt(x: number): number;\n\n    /**\n     * Returns the smallest number greater than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::ceil\n    function ceil(x: number): number;\n\n    /**\n      * Returns the greatest number less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::floor\n    function floor(x: number): number;\n\n    /**\n      * Returns the number with the decimal part truncated.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::trunc\n    function trunc(x: number): number;\n\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    //% shim=Math_::round\n    function round(x: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit multiplication of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::imul\n    function imul(x: number, y: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit division of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::idiv\n    function idiv(x: number, y: number): number;\n}\n",
      "pxt-helpers.ts": "type Action = () => void;\n\nnamespace helpers {\n    export function arraySplice<T>(arr: T[], start: number, len: number) {\n        if (start < 0) {\n            return;\n        }\n        for (let i = 0; i < len; ++i) {\n            arr.removeAt(start)\n        }\n    }\n\n    export function arrayReverse<T>(arr: T[]): void {\n        let len = arr.length;\n        for (let i = 0; i < len / 2; i++) {\n            swap(arr, i, len - i - 1);\n        }\n    }\n\n    export function arrayShift<T>(arr: T[]): T {\n        return arr.removeAt(0);\n    }\n\n    /*TODO: Enable this multiple value unshift, after rest is enabled in our compiler.\n        export function arrayUnshift<T>(arr: T[], ...values: T[]) : number {\n            for(let i = values.length; i > 0; --i) {\n                arr.insertAt(0, values[i - 1]);\n            }\n            return arr.length;\n        }\n    */\n    export function arrayUnshift<T>(arr: T[], value: T): number {\n        arr.insertAt(0, value);\n        return arr.length;\n    }\n\n    function swap<T>(arr: T[], i: number, j: number): void {\n        let temp: T = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    function sortHelper<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (arr.length <= 0 || !callbackfn) {\n            return arr;\n        }\n        let len = arr.length;\n        // simple selection sort.\n        for (let i = 0; i < len - 1; ++i) {\n            for (let j = i + 1; j < len; ++j) {\n                if (callbackfn(arr[i], arr[j]) > 0) {\n                    swap(arr, i, j);\n                }\n            }\n        }\n        return arr;\n    }\n\n    export function arraySort<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (!callbackfn) {\n            //TODO: support native strings and number sorting\n            /* callbackfn = function (value1: string, value2: string) : number {\n                return value1.compare(value2);\n                }*/\n        }\n        return sortHelper(arr, callbackfn);\n    }\n\n    export function arrayMap<T, U>(arr: T[], callbackfn: (value: T, index: number) => U): U[] {\n        let res: U[] = []\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            res.push(callbackfn(arr[i], i))\n        }\n        return res\n    }\n\n    export function arrayFilter<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T[] {\n        let res: T[] = []\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) res.push(v)\n        }\n        return res\n    }\n\n    export function arrayReduce<T, U>(arr: T[], callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            initialValue = callbackfn(initialValue, arr[i], i)\n        }\n        return initialValue\n    }\n\n    export function arraySlice<T>(arr: T[], start: number, end: number): T[] {\n        const res: T[] = [];\n        const len = arr.length;\n\n        if (start < 0) {\n            start = Math.max(len + start, 0);\n        }\n\n        if (end < 0) {\n            end = len + end;\n        }\n\n        const sliceLength = end - start;\n\n        for (let i = 0; i < sliceLength; ++i) {\n            const index = i + start;\n            if (index >= len) {\n                break;\n            }\n            res.push(arr[index]);\n        }\n        return res;\n    }\n}\n\nnamespace Math {\n    export function clamp(min: number, max: number, value: number): number {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    export function abs(x: number): number {\n        return x < 0 ? -x : x;\n    }\n\n    /**\n      * Returns the sign of the x, indicating whether x is positive, negative or zero.\n      * @param x The numeric expression to test\n      */\n    export function sign(x: number): number {\n        if (x == 0) return 0;\n        if (x > 0) return 1;\n        return -1;\n    }\n\n    /**\n      * Returns the larger of two supplied numeric expressions.\n      */\n    export function max(a: number, b: number): number {\n        if (a >= b) return a;\n        return b;\n    }\n\n    /**\n      * Returns the smaller of two supplied numeric expressions.\n      */\n    export function min(a: number, b: number): number {\n        if (a <= b) return a;\n        return b;\n    }\n}\n",
      "pxt.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\nnamespace pxt {\n\nTValue incr(TValue e) {\n    if (isRefCounted(e)) {\n        getVTable((RefObject *)e);\n#if MEMDBG_ENABLED\n        if (((RefObject *)e)->refcnt != 0xffff)\n            MEMDBG(\"INCR: %p refs=%d\", e, ((RefObject *)e)->refcnt);\n#endif\n        ((RefObject *)e)->ref();\n    }\n    return e;\n}\n\nvoid decr(TValue e) {\n    if (isRefCounted(e)) {\n#if MEMDBG_ENABLED\n        if (((RefObject *)e)->refcnt != 0xffff)\n            MEMDBG(\"DECR: %p refs=%d\", e, ((RefObject *)e)->refcnt);\n#endif\n        ((RefObject *)e)->unref();\n    }\n}\n\n// TODO\nAction mkAction(int reflen, int totallen, int startptr) {\n    check(0 <= reflen && reflen <= totallen, ERR_SIZE, 1);\n    check(reflen <= totallen && totallen <= 255, ERR_SIZE, 2);\n    check(bytecode[startptr] == 0xffff, ERR_INVALID_BINARY_HEADER, 3);\n    check(bytecode[startptr + 1] == PXT_REF_TAG_ACTION, ERR_INVALID_BINARY_HEADER, 4);\n\n    unsigned tmp = (unsigned)&bytecode[startptr];\n\n    if (totallen == 0) {\n        return (TValue)tmp; // no closure needed\n    }\n\n    void *ptr = ::operator new(sizeof(RefAction) + totallen * sizeof(unsigned));\n    RefAction *r = new (ptr) RefAction();\n    r->len = totallen;\n    r->reflen = reflen;\n    r->func = (ActionCB)((tmp + 4) | 1);\n    memset(r->fields, 0, r->len * sizeof(unsigned));\n\n    MEMDBG(\"mkAction: start=%p => %p\", startptr, r);\n\n    return (Action)r;\n}\n\n// TODO\nTValue runAction3(Action a, TValue arg0, TValue arg1, TValue arg2) {\n    auto aa = (RefAction *)a;\n    if (aa->vtable == PXT_REF_TAG_ACTION) {\n        check(aa->refcnt == 0xffff, ERR_INVALID_BINARY_HEADER, 4);\n        return ((ActionCB)(((uint32_t)a + 4) | 1))(NULL, arg0, arg1, arg2);\n    } else {\n        check(aa->refcnt != 0xffff, ERR_INVALID_BINARY_HEADER, 4);\n        return aa->runCore(arg0, arg1, arg2);\n    }\n}\n\nTValue runAction2(Action a, TValue arg0, TValue arg1) {\n    return runAction3(a, arg0, arg1, 0);\n}\n\nTValue runAction1(Action a, TValue arg0) {\n    return runAction3(a, arg0, 0, 0);\n}\n\nTValue runAction0(Action a) {\n    return runAction3(a, 0, 0, 0);\n}\n\nRefRecord *mkClassInstance(int vtableOffset) {\n    VTable *vtable = (VTable *)&bytecode[vtableOffset];\n\n    intcheck(vtable->methods[0] == &RefRecord_destroy, ERR_SIZE, 3);\n    intcheck(vtable->methods[1] == &RefRecord_print, ERR_SIZE, 4);\n\n    void *ptr = ::operator new(vtable->numbytes);\n    RefRecord *r = new (ptr) RefRecord(PXT_VTABLE_TO_INT(vtable));\n    memset(r->fields, 0, vtable->numbytes - sizeof(RefRecord));\n    MEMDBG(\"mkClass: vt=%p => %p\", vtable, r);\n    return r;\n}\n\nTValue RefRecord::ld(int idx) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, ERR_OUT_OF_BOUNDS, 1);\n    return fields[idx];\n}\n\nTValue RefRecord::ldref(int idx) {\n    // DMESG(\"LD %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, ERR_OUT_OF_BOUNDS, 2);\n    TValue tmp = fields[idx];\n    incr(tmp);\n    return tmp;\n}\n\nvoid RefRecord::st(int idx, TValue v) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, ERR_OUT_OF_BOUNDS, 3);\n    fields[idx] = v;\n}\n\nvoid RefRecord::stref(int idx, TValue v) {\n    // DMESG(\"ST %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, ERR_OUT_OF_BOUNDS, 4);\n    decr(fields[idx]);\n    fields[idx] = v;\n}\n\nvoid RefObject::destroyVT() {\n    ((RefObjectMethod)getVTable(this)->methods[0])(this);\n    ::operator delete(this);\n}\n\nvoid RefObject::printVT() {\n    ((RefObjectMethod)getVTable(this)->methods[1])(this);\n}\n\nvoid RefRecord_destroy(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    uint8_t *refmask = (uint8_t *)&tbl->methods[tbl->userdata & 0xff];\n    int len = (tbl->numbytes >> 2) - 1;\n    for (int i = 0; i < len; ++i) {\n        if (refmask[i])\n            decr(r->fields[i]);\n        r->fields[i] = 0;\n    }\n}\n\nvoid RefRecord_print(RefRecord *r) {\n    DMESG(\"RefRecord %p r=%d size=%d bytes\", r, r->refcnt, getVTable(r)->numbytes);\n}\n\nTValue Segment::get(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::get index:%d\", i);\n    this->print();\n#endif\n\n    if (i < length) {\n        return data[i];\n    }\n    return Segment::DefaultValue;\n}\n\nvoid Segment::setRef(unsigned i, TValue value) {\n    decr(get(i));\n    set(i, value);\n}\n\nvoid Segment::set(unsigned i, TValue value) {\n    if (i < size) {\n        data[i] = value;\n    } else if (i < Segment::MaxSize) {\n        growByMin(i + 1);\n        data[i] = value;\n    }\n    if (length <= i) {\n        length = i + 1;\n    }\n\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::set\");\n    this->print();\n#endif\n\n    return;\n}\n\nuint16_t Segment::growthFactor(uint16_t size) {\n    if (size == 0) {\n        return 4;\n    }\n    if (size < 64) {\n        return size * 2; // Double\n    }\n    if (size < 512) {\n        return size * 5 / 3; // Grow by 1.66 rate\n    }\n    return size + 256; // Grow by constant rate\n}\n\nvoid Segment::growByMin(uint16_t minSize) {\n    growBy(max(minSize, growthFactor(size)));\n}\n\nvoid Segment::growBy(uint16_t newSize) {\n#ifdef DEBUG_BUILD\n    DMESG(\"growBy: %d\", newSize);\n    this->print();\n#endif\n    if (size < newSize) {\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(::operator new(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size) {\n            memcpy(tmp, data, size * sizeof(TValue));\n        }\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        // free older segment;\n        ::operator delete(data);\n\n        data = tmp;\n        size = newSize;\n\n#ifdef DEBUG_BUILD\n        DMESG(\"growBy - after reallocation\");\n        this->print();\n#endif\n    }\n    // else { no shrinking yet; }\n    return;\n}\n\nvoid Segment::ensure(uint16_t newSize) {\n    if (newSize < size) {\n        return;\n    }\n    growByMin(newSize);\n}\n\nvoid Segment::setLength(unsigned newLength) {\n    if (newLength > size) {\n        ensure(length);\n    }\n    length = newLength;\n    return;\n}\n\nvoid Segment::push(TValue value) {\n    this->set(length, value);\n}\n\nTValue Segment::pop() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::pop\");\n    this->print();\n#endif\n\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = Segment::DefaultValue;\n        return value;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function removes an element at index i and shifts the rest of the elements to\n// left to fill the gap\nTValue Segment::remove(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::remove index:%d\", i);\n    this->print();\n#endif\n    if (i < length) {\n        // value to return\n        TValue ret = data[i];\n        if (i + 1 < length) {\n            // Move the rest of the elements to fill in the gap.\n            memmove(data + i, data + i + 1, (length - i - 1) * sizeof(unsigned));\n        }\n        length--;\n        data[length] = Segment::DefaultValue;\n#ifdef DEBUG_BUILD\n        DMESG(\"After Segment::remove index:%d\", i);\n        this->print();\n#endif\n        return ret;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function inserts element value at index i by shifting the rest of the elements right.\nvoid Segment::insert(unsigned i, TValue value) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::insert index:%d value:%d\", i, value);\n    this->print();\n#endif\n\n    if (i < length) {\n        ensure(length + 1);\n        if (i + 1 < length) {\n            // Move the rest of the elements to fill in the gap.\n            memmove(data + i + 1, data + i, (length - i) * sizeof(unsigned));\n        }\n\n        data[i] = value;\n        length++;\n    } else {\n        // This is insert beyond the length, just call set which will adjust the length\n        set(i, value);\n    }\n#ifdef DEBUG_BUILD\n    DMESG(\"After Segment::insert index:%d\", i);\n    this->print();\n#endif\n}\n\nvoid Segment::print() {\n    DMESG(\"Segment: %p, length: %d, size: %d\", data, (unsigned)length, (unsigned)size);\n    for (unsigned i = 0; i < size; i++) {\n        DMESG(\"-> %d\", (unsigned)data[i]);\n    }\n}\n\nbool Segment::isValidIndex(unsigned i) {\n    if (i > length) {\n        return false;\n    }\n    return true;\n}\n\nvoid Segment::destroy() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::destroy\");\n    this->print();\n#endif\n    length = size = 0;\n    ::operator delete(data);\n    data = nullptr;\n}\n\nvoid RefCollection::push(TValue x) {\n    incr(x);\n    head.push(x);\n}\n\nTValue RefCollection::pop() {\n    TValue ret = head.pop();\n    incr(ret);\n    return ret;\n}\n\nTValue RefCollection::getAt(int i) {\n    TValue tmp = head.get(i);\n    incr(tmp);\n    return tmp;\n}\n\nTValue RefCollection::removeAt(int i) {\n    return head.remove(i);\n}\n\nvoid RefCollection::insertAt(int i, TValue value) {\n    head.insert(i, value);\n    incr(value);\n}\n\nvoid RefCollection::setAt(int i, TValue value) {\n    incr(value);\n    head.setRef(i, value);\n}\n\nint RefCollection::indexOf(TValue x, int start) {\n    unsigned i = start;\n    while (head.isValidIndex(i)) {\n        if (pxt::eq_bool(head.get(i), x)) {\n            return (int)i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nbool RefCollection::removeElement(TValue x) {\n    int idx = indexOf(x, 0);\n    if (idx >= 0) {\n        decr(removeAt(idx));\n        return 1;\n    }\n    return 0;\n}\n\nnamespace Coll0 {\nPXT_VTABLE_BEGIN(RefCollection, 0, 0)\nPXT_VTABLE_END\n} // namespace Coll0\n\nRefCollection::RefCollection() : RefObject(0) {\n    vtable = PXT_VTABLE_TO_INT(&Coll0::RefCollection_vtable);\n}\n\nvoid RefCollection::destroy() {\n    for (unsigned i = 0; i < this->head.getLength(); i++) {\n        decr(this->head.get(i));\n    }\n    this->head.destroy();\n}\n\nvoid RefCollection::print() {\n    DMESG(\"RefCollection %p r=%d size=%d\", this, refcnt, head.getLength());\n    head.print();\n}\n\nPXT_VTABLE_CTOR(RefAction) {}\n\n// fields[] contain captured locals\nvoid RefAction::destroy() {\n    for (int i = 0; i < this->reflen; ++i) {\n        decr(fields[i]);\n        fields[i] = 0;\n    }\n}\n\nvoid RefAction::print() {\n    DMESG(\"RefAction %p r=%d pc=%X size=%d (%d refs)\", this, refcnt,\n          (const uint8_t *)func - (const uint8_t *)bytecode, len, reflen);\n}\n\nvoid RefLocal::print() {\n    DMESG(\"RefLocal %p r=%d v=%d\", this, refcnt, v);\n}\n\nvoid RefLocal::destroy() {}\n\nPXT_VTABLE_CTOR(RefLocal) {\n    v = 0;\n}\n\nPXT_VTABLE_CTOR(RefRefLocal) {\n    v = 0;\n}\n\nvoid RefRefLocal::print() {\n    DMESG(\"RefRefLocal %p r=%d v=%p\", this, refcnt, (void *)v);\n}\n\nvoid RefRefLocal::destroy() {\n    decr(v);\n}\n\nPXT_VTABLE_BEGIN(RefMap, 0, RefMapMarker)\nPXT_VTABLE_END\nRefMap::RefMap() : PXT_VTABLE_INIT(RefMap) {}\n\nvoid RefMap::destroy() {\n    for (unsigned i = 0; i < values.getLength(); ++i) {\n        decr(values.get(i));\n        values.set(i, 0);\n    }\n    keys.destroy();\n    values.destroy();\n}\n\nint RefMap::findIdx(unsigned key) {\n    for (unsigned i = 0; i < keys.getLength(); ++i) {\n        if ((unsigned)keys.get(i) == key)\n            return i;\n    }\n    return -1;\n}\n\nvoid RefMap::print() {\n    DMESG(\"RefMap %p r=%d size=%d\", this, refcnt, keys.getLength());\n}\n\n#ifdef PXT_MEMLEAK_DEBUG\nstd::set<TValue> allptrs;\nvoid debugMemLeaks() {\n    DMESG(\"LIVE POINTERS:\");\n    for (std::set<TValue>::iterator itr = allptrs.begin(); itr != allptrs.end(); itr++) {\n        anyPrint(*itr);\n    }\n    DMESG(\"LIVE POINTERS END.\");\n    dumpDmesg();\n}\n#else\nvoid debugMemLeaks() {}\n#endif\n\nvoid error(ERROR code, int subcode) {\n    DMESG(\"Error: %d [%d]\", code, subcode);\n    target_panic(42);\n}\n\nuint16_t *bytecode;\nTValue *globals;\n\nunsigned *allocate(uint16_t sz) {\n    unsigned *arr = new unsigned[sz];\n    memset(arr, 0, sz * sizeof(unsigned));\n    return arr;\n}\n\nvoid checkStr(bool cond, const char *msg) {\n    if (!cond) {\n        while (true) {\n            // uBit.display.scroll(msg, 100);\n            // uBit.sleep(100);\n        }\n    }\n}\n\nint templateHash() {\n    return ((int *)bytecode)[4];\n}\n\nint programHash() {\n    return ((int *)bytecode)[6];\n}\n\nint getNumGlobals() {\n    return bytecode[16];\n}\n\nvoid exec_binary(unsigned *pc) {\n    // XXX re-enable once the calibration code is fixed and [editor/embedded.ts]\n    // properly prepends a call to [internal_main].\n    // ::touch_develop::internal_main();\n\n    // unique group for radio based on source hash\n    // ::touch_develop::micro_bit::radioDefaultGroup = programHash();\n\n    // repeat error 4 times and restart as needed\n    // microbit_panic_timeout(4);\n\n    unsigned ver = *pc++;\n    checkStr(ver == 0x4209, \":( Bad runtime version\");\n\n    bytecode = *((uint16_t **)pc++); // the actual bytecode is here\n    globals = (TValue *)allocate(getNumGlobals());\n\n    // can be any valid address, best in RAM for speed\n    globals[0] = (TValue)&globals;\n\n    // just compare the first word\n    // TODO\n    checkStr(((uint32_t *)bytecode)[0] == 0x923B8E70 && (unsigned)templateHash() == *pc,\n             \":( Failed partial flash\");\n\n    unsigned startptr = (unsigned)bytecode;\n\n    startptr += 48; // header\n    startptr |= 1;  // Thumb state\n\n    initRuntime();\n\n    ((unsigned (*)())startptr)();\n\n#ifdef PXT_MEMLEAK_DEBUG\n    pxt::debugMemLeaks();\n#endif\n\n    while (1) {\n        sleep_ms(10000);\n    }\n}\n\nvoid start() {\n    exec_binary((unsigned *)functionsAndBytecode);\n}\n\n} // namespace pxt\n",
      "pxt.json": "{\n  \"name\": \"base\",\n  \"description\": \"The base library\",\n  \"files\": [\n    \"README.md\",\n    \"pxt-core.d.ts\",\n    \"pxt.cpp\",\n    \"pxtbase.h\",\n    \"core.cpp\",\n    \"pxt-helpers.ts\",\n    \"buffer.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"loops.cpp\",\n    \"loops.ts\",\n    \"math.ts\",\n    \"ns.ts\",\n    \"control.cpp\",\n    \"control.ts\",\n    \"serial.cpp\",\n    \"serial.ts\",\n    \"console.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {}\n}",
      "pxtbase.h": "#ifndef __PXTBASE_H\n#define __PXTBASE_H\n\n//#define PXT_MEMLEAK_DEBUG 1\n\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wformat\"\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n\n// needed for gcc6; not sure why\n#undef min\n#undef max\n\n#define NOLOG(...)                                                                                 \\\n    do {                                                                                           \\\n    } while (0)\n\n\n#define MEMDBG_ENABLED 0\n#define MEMDBG NOLOG\n\n#include \"pxtconfig.h\"\n\n#define intcheck(...) check(__VA_ARGS__)\n//#define intcheck(...) do {} while (0)\n\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n\n#include <new>\n\n#ifdef PXT_MEMLEAK_DEBUG\n#include <set>\n#endif\n\n#include \"pxtcore.h\"\n\n#define CONCAT_1(a, b) a##b\n#define CONCAT_0(a, b) CONCAT_1(a, b)\n#define STATIC_ASSERT(e) enum { CONCAT_0(_static_assert_, __LINE__) = 1 / ((e) ? 1 : 0) };\n\n#if 0\ninline void *operator new(size_t, void *p) {\n    return p;\n}\ninline void *operator new[](size_t, void *p) {\n    return p;\n}\n#endif\n\nnamespace pxt {\n\ntemplate <typename T> inline const T &max(const T &a, const T &b) {\n    if (a < b)\n        return b;\n    return a;\n}\n\ntemplate <typename T> inline const T &min(const T &a, const T &b) {\n    if (a < b)\n        return a;\n    return b;\n}\n\ntemplate <typename T> inline void swap(T &a, T &b) {\n    T tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//\n// Tagged values (assume 4 bytes for now, Cortex-M0)\n//\nstruct TValueStruct {};\ntypedef TValueStruct *TValue;\n\ntypedef TValue TNumber;\ntypedef TValue Action;\ntypedef TValue ImageLiteral;\n\n// To be implemented by the target\nextern \"C\" void target_panic(int error_code);\nextern \"C\" void target_reset();\nvoid sleep_ms(unsigned ms);\nvoid sleep_us(uint64_t us);\nint current_time_ms();\nvoid initRuntime();\nvoid sendSerial(const char *data, int len);\nint getSerialNumber();\nvoid registerWithDal(int id, int event, Action a, int flags = 16); // EVENT_LISTENER_DEFAULT_FLAGS\nvoid runInBackground(Action a);\nvoid runForever(Action a);\nvoid waitForEvent(int id, int event);\n//%\nunsigned afterProgramPage();\n//%\nvoid dumpDmesg();\n\n// also defined DMESG macro\n// end\n\n#define TAGGED_SPECIAL(n) (TValue)(void *)((n << 2) | 2)\n#define TAG_FALSE TAGGED_SPECIAL(2)\n#define TAG_TRUE TAGGED_SPECIAL(16)\n#define TAG_UNDEFINED (TValue)0\n#define TAG_NULL TAGGED_SPECIAL(1)\n#define TAG_NUMBER(n) (TNumber)(void *)((n << 1) | 1)\n\ninline bool isTagged(TValue v) {\n    return ((int)v & 3) || !v;\n}\n\ninline bool isNumber(TValue v) {\n    return (int)v & 1;\n}\n\ninline bool isSpecial(TValue v) {\n    return (int)v & 2;\n}\n\ninline bool bothNumbers(TValue a, TValue b) {\n    return (int)a & (int)b & 1;\n}\n\ninline int numValue(TValue n) {\n    return (int)n >> 1;\n}\n\n#ifdef PXT_BOX_DEBUG\ninline bool canBeTagged(int) {\n    return false;\n}\n#else\ninline bool canBeTagged(int v) {\n    return (v << 1) >> 1 == v;\n}\n#endif\n\ntypedef enum {\n    ERR_INVALID_BINARY_HEADER = 5,\n    ERR_OUT_OF_BOUNDS = 8,\n    ERR_REF_DELETED = 7,\n    ERR_SIZE = 9,\n} ERROR;\n\nextern const unsigned functionsAndBytecode[];\nextern TValue *globals;\nextern uint16_t *bytecode;\nclass RefRecord;\n\n// Utility functions\n\n//%\nTValue runAction3(Action a, TValue arg0, TValue arg1, TValue arg2);\n//%\nTValue runAction2(Action a, TValue arg0, TValue arg1);\n//%\nTValue runAction1(Action a, TValue arg0);\n//%\nTValue runAction0(Action a);\n//%\nAction mkAction(int reflen, int totallen, int startptr);\n// allocate [sz] words and clear them\n//%\nunsigned *allocate(uint16_t sz);\n//%\nint templateHash();\n//%\nint programHash();\n//%\nunsigned programSize();\n//%\nint getNumGlobals();\n//%\nRefRecord *mkClassInstance(int vtableOffset);\n//%\nvoid debugMemLeaks();\n//%\nvoid anyPrint(TValue v);\n\nint getConfig(int key, int defl = -1);\n\n//%\nint toInt(TNumber v);\n//%\nunsigned toUInt(TNumber v);\n//%\ndouble toDouble(TNumber v);\n//%\nfloat toFloat(TNumber v);\n//%\nTNumber fromDouble(double r);\n//%\nTNumber fromFloat(float r);\n\n//%\nTNumber fromInt(int v);\n//%\nTNumber fromUInt(unsigned v);\n//%\nTValue fromBool(bool v);\n//%\nbool eq_bool(TValue a, TValue b);\n//%\nbool eqq_bool(TValue a, TValue b);\n\nvoid error(ERROR code, int subcode = 0);\nvoid exec_binary(unsigned *pc);\nvoid start();\n\nstruct HandlerBinding {\n    HandlerBinding *next;\n    int source;\n    int value;\n    Action action;\n};\nHandlerBinding *findBinding(int source, int value);\nvoid setBinding(int source, int value, Action act);\n\n// The standard calling convention is:\n//   - when a pointer is loaded from a local/global/field etc, and incr()ed\n//     (in other words, its presence on stack counts as a reference)\n//   - after a function call, all pointers are popped off the stack and decr()ed\n// This does not apply to the RefRecord and st/ld(ref) methods - they unref()\n// the RefRecord* this.\n//%\nTValue incr(TValue e);\n//%\nvoid decr(TValue e);\n\nclass RefObject;\n\nstatic inline RefObject *incrRC(RefObject *r) {\n    return (RefObject *)incr((TValue)r);\n}\nstatic inline void decrRC(RefObject *r) {\n    decr((TValue)r);\n}\n\ninline void *ptrOfLiteral(int offset) {\n    return &bytecode[offset];\n}\n\n// Checks if object is ref-counted, and has a custom PXT vtable in front\n// TODO\ninline bool isRefCounted(TValue e) {\n    return !isTagged(e) && (*((unsigned *)e) & 1) == 1;\n}\n\ninline void check(int cond, ERROR code, int subcode = 0) {\n    if (!cond)\n        error(code, subcode);\n}\n\ninline void oops() {\n    target_panic(47);\n}\n\nclass RefObject;\n#ifdef PXT_MEMLEAK_DEBUG\nextern std::set<TValue> allptrs;\n#endif\n\ntypedef void (*RefObjectMethod)(RefObject *self);\ntypedef void *PVoid;\ntypedef void **PPVoid;\n\nconst PPVoid RefMapMarker = (PPVoid)(void *)43;\n\nstruct VTable {\n    uint16_t numbytes; // in the entire object, including the vtable pointer\n    uint16_t userdata;\n    PVoid *ifaceTable;\n    PVoid methods[2]; // we only use up to two methods here; pxt will generate more\n                      // refmask sits at &methods[nummethods]\n};\n\nconst int vtableShift = 2;\n\n// A base abstract class for ref-counted objects.\nclass RefObject {\n  public:\n    uint16_t refcnt;\n    uint16_t vtable;\n\n    RefObject(uint16_t vt) {\n        refcnt = 3;\n        vtable = vt;\n#ifdef PXT_MEMLEAK_DEBUG\n        allptrs.insert((TValue)this);\n#endif\n    }\n\n    void destroyVT();\n    void printVT();\n\n    // Call to disable pointer tracking on the current instance (in destructor or some other hack)\n    inline void untrack() {\n#ifdef PXT_MEMLEAK_DEBUG\n        allptrs.erase((TValue)this);\n#endif\n    }\n\n    // Increment/decrement the ref-count. Decrementing to zero deletes the current object.\n    inline void ref() {\n        if (refcnt == 0xffff)\n            return;\n        check(refcnt > 1, ERR_REF_DELETED);\n        // DMESG(\"INCR \"); this->print();\n        refcnt += 2;\n    }\n\n    inline void unref() {\n        if (refcnt == 0xffff)\n            return;\n        check(refcnt > 1, ERR_REF_DELETED);\n        check((refcnt & 1), ERR_REF_DELETED);\n        // DMESG(\"DECR \"); this->print();\n        refcnt -= 2;\n        if (refcnt == 1) {\n            untrack();\n            destroyVT();\n        }\n    }\n};\n\nclass Segment {\n  private:\n    TValue *data;\n    uint16_t length;\n    uint16_t size;\n\n    static constexpr uint16_t MaxSize = 0xFFFF;\n    static constexpr TValue DefaultValue = TAG_UNDEFINED;\n\n    static uint16_t growthFactor(uint16_t size);\n    void growByMin(uint16_t minSize);\n    void growBy(uint16_t newSize);\n    void ensure(uint16_t newSize);\n\n  public:\n    Segment() : data(nullptr), length(0), size(0){};\n\n    TValue get(unsigned i);\n    void set(unsigned i, TValue value);\n    void setRef(unsigned i, TValue value);\n\n    unsigned getLength() { return length; };\n    void setLength(unsigned newLength);\n    void resize(unsigned newLength) { setLength(newLength); }\n\n    void push(TValue value);\n    TValue pop();\n\n    TValue remove(unsigned i);\n    void insert(unsigned i, TValue value);\n\n    bool isValidIndex(unsigned i);\n\n    void destroy();\n\n    void print();\n};\n\n// A ref-counted collection of either primitive or ref-counted objects (String, Image,\n// user-defined record, another collection)\nclass RefCollection : public RefObject {\n  private:\n    Segment head;\n\n  public:\n    RefCollection();\n\n    void destroy();\n    void print();\n\n    unsigned length() { return head.getLength(); }\n    void setLength(unsigned newLength) { head.setLength(newLength); }\n\n    void push(TValue x);\n    TValue pop();\n    TValue getAt(int i);\n    void setAt(int i, TValue x);\n    // removes the element at index i and shifts the other elements left\n    TValue removeAt(int i);\n    // inserts the element at index i and moves the other elements right.\n    void insertAt(int i, TValue x);\n\n    int indexOf(TValue x, int start);\n    bool removeElement(TValue x);\n};\n\nclass RefMap : public RefObject {\n  public:\n    Segment keys;\n    Segment values;\n\n    RefMap();\n    void destroy();\n    void print();\n    int findIdx(unsigned key);\n};\n\n// A ref-counted, user-defined JS object.\nclass RefRecord : public RefObject {\n  public:\n    // The object is allocated, so that there is space at the end for the fields.\n    TValue fields[];\n\n    RefRecord(uint16_t v) : RefObject(v) {}\n\n    TValue ld(int idx);\n    TValue ldref(int idx);\n    void st(int idx, TValue v);\n    void stref(int idx, TValue v);\n};\n\n//%\nVTable *getVTable(RefObject *r);\n\n// these are needed when constructing vtables for user-defined classes\n//%\nvoid RefRecord_destroy(RefRecord *r);\n//%\nvoid RefRecord_print(RefRecord *r);\n\nclass RefAction;\ntypedef TValue (*ActionCB)(TValue *captured, TValue arg0, TValue arg1, TValue arg2);\n\n// Ref-counted function pointer.\nclass RefAction : public RefObject {\n  public:\n    // This is the same as for RefRecord.\n    uint8_t len;\n    uint8_t reflen;\n    ActionCB func; // The function pointer\n    // fields[] contain captured locals\n    TValue fields[];\n\n    void destroy();\n    void print();\n\n    RefAction();\n\n    inline void stCore(int idx, TValue v) {\n        // DMESG(\"ST [%d] = %d \", idx, v); this->print();\n        intcheck(0 <= idx && idx < len, ERR_OUT_OF_BOUNDS, 10);\n        intcheck(fields[idx] == 0, ERR_OUT_OF_BOUNDS, 11); // only one assignment permitted\n        fields[idx] = v;\n    }\n\n    inline TValue runCore(TValue arg0, TValue arg1,\n                          TValue arg2) // internal; use runAction*() functions\n    {\n        this->ref();\n        TValue r = this->func(&this->fields[0], arg0, arg1, arg2);\n        this->unref();\n        return r;\n    }\n};\n\n// These two are used to represent locals written from inside inline functions\nclass RefLocal : public RefObject {\n  public:\n    TValue v;\n    void destroy();\n    void print();\n    RefLocal();\n};\n\nclass RefRefLocal : public RefObject {\n  public:\n    TValue v;\n    void destroy();\n    void print();\n    RefRefLocal();\n};\n\n// note: this is hardcoded in PXT (hexfile.ts)\n\n#define PXT_REF_TAG_STRING 1\n#define PXT_REF_TAG_BUFFER 2\n#define PXT_REF_TAG_IMAGE 3\n#define PXT_REF_TAG_NUMBER 32\n#define PXT_REF_TAG_ACTION 33\n\nclass BoxedNumber : public RefObject {\n  public:\n    double num;\n    BoxedNumber() : RefObject(PXT_REF_TAG_NUMBER) {}\n} __attribute__((packed));\n\nclass BoxedString : public RefObject {\n  public:\n    uint16_t length;\n    char data[0];\n    BoxedString() : RefObject(PXT_REF_TAG_STRING) {}\n};\n\nclass BoxedBuffer : public RefObject {\n  public:\n    uint16_t length;\n    uint8_t data[0];\n    BoxedBuffer() : RefObject(PXT_REF_TAG_BUFFER) {}\n};\n\ntypedef BoxedBuffer *Buffer;\ntypedef BoxedString *String;\n\n// keep in sync with github/pxt/pxtsim/libgeneric.ts\nenum class NumberFormat {\n    Int8LE = 1,\n    UInt8LE,\n    Int16LE,\n    UInt16LE,\n    Int32LE,\n    Int8BE,\n    UInt8BE,\n    Int16BE,\n    UInt16BE,\n    Int32BE,\n\n    UInt32LE,\n    UInt32BE,\n    Float32LE,\n    Float64LE,\n    Float32BE,\n    Float64BE,\n};\n\n// data can be NULL in both cases\nString mkString(const char *data, int len = -1);\nBuffer mkBuffer(const uint8_t *data, int len);\n\nTNumber getNumberCore(uint8_t *buf, int size, NumberFormat format);\nvoid setNumberCore(uint8_t *buf, int size, NumberFormat format, TNumber value);\n\nTNumber mkNaN();\n\nvoid seedRandom(unsigned seed);\n// max is inclusive\nunsigned getRandom(unsigned max);\n\nextern const VTable string_vt;\nextern const VTable image_vt;\nextern const VTable buffer_vt;\nextern const VTable number_vt;\nextern const VTable RefAction_vtable;\n\nenum class ValType {\n    Undefined,\n    Boolean,\n    Number,\n    String,\n    Object,\n    Function,\n};\n\nValType valType(TValue v);\n} // namespace pxt\n\n// The initial six bytes of the strings (@PXT@:) are rewritten\n// to the proper ref-count and vtable pointer\n#define PXT_DEF_STRING(name, val)                                                                  \\\n    static const char name[] __attribute__((aligned(4))) = \"@PXT@:\" val;\n\nusing namespace pxt;\n\nnamespace pins {\nBuffer createBuffer(int size);\n}\n\n// The ARM Thumb generator in the JavaScript code is parsing\n// the hex file and looks for the magic numbers as present here.\n//\n// Then it fetches function pointer addresses from there.\n//\n// The vtable pointers are there, so that the ::emptyData for various types\n// can be patched with the right vtable.\n//\n#define PXT_SHIMS_BEGIN                                                                            \\\n    namespace pxt {                                                                                \\\n    const unsigned functionsAndBytecode[]                                                          \\\n        __attribute__((aligned(0x20))) = {0x08010801, 0x42424242, 0x08010801, 0x8de9d83e,\n\n#define PXT_SHIMS_END                                                                              \\\n    }                                                                                              \\\n    ;                                                                                              \\\n    }\n\n#pragma GCC diagnostic ignored \"-Wpmf-conversions\"\n\n#define PXT_VTABLE_TO_INT(vt) ((unsigned)(vt) >> vtableShift)\n#define PXT_VTABLE_BEGIN(classname, flags, iface)                                                  \\\n    const VTable classname##_vtable __attribute__((aligned(1 << vtableShift))) = {                 \\\n        sizeof(classname), flags, iface, {(void *)&classname::destroy, (void *)&classname::print,\n\n#define PXT_VTABLE_END                                                                             \\\n    }                                                                                              \\\n    }                                                                                              \\\n    ;\n\n#define PXT_VTABLE_INIT(classname) RefObject(PXT_VTABLE_TO_INT(&classname##_vtable))\n\n#define PXT_VTABLE_CTOR(classname)                                                                 \\\n    PXT_VTABLE_BEGIN(classname, 0, 0)                                                              \\\n    PXT_VTABLE_END classname::classname() : PXT_VTABLE_INIT(classname)\n\n#define PXT_MAIN                                                                                   \\\n    int main() {                                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#define PXT_FNPTR(x) (unsigned)(void *)(x)\n\n#define JOIN(a, b) a##b\n/// Defines getClassName() function to fetch the singleton\n#define SINGLETON(ClassName)                                                                       \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName))                                                                \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n#endif\n",
      "serial.cpp": "#include \"pxtbase.h\"\n\nnamespace serial {\n    // note that at least one // followed by % is needed per declaration!\n\n    /**\n     * Write some text to the serial port.\n     */\n    //% help=serial/write-string\n    //% weight=87 blockHidden=true\n    //% blockId=serial_writestring block=\"serial|write string %text\"\n    void writeString(String text) {\n      sendSerial(text->data, text->length);\n    }\n\n    /**\n    * Send a buffer across the serial connection.\n    */\n    //% help=serial/write-buffer weight=6 blockHidden=true\n    //% blockId=serial_writebuffer block=\"serial|write buffer %buffer\"\n    void writeBuffer(Buffer buffer) {\n      if (!buffer) return;\n      sendSerial((char*)buffer->data, buffer->length);\n    }\n}\n",
      "serial.ts": "/**\n * Reading and writing data over a serial connection.\n */\n//% weight=2 color=#002050 icon=\"\\uf287\"\n//% advanced=true\nnamespace serial {\n    /**\n     * Write a line of text to the serial port.\n     * @param value to send over serial\n     */\n    //% weight=90\n    //% help=serial/write-line blockGap=8 blockHidden=true\n    //% blockId=serial_writeline block=\"serial|write line %text\"\n    export function writeLine(text: string): void {\n        writeString(text + \"\\r\\n\");\n    }\n\n    /**\n     * Write a number to the serial port.\n     */\n    //% help=serial/write-number\n    //% weight=89 blockGap=8 blockHidden=true\n    //% blockId=serial_writenumber block=\"serial|write number %value\"\n    export function writeNumber(value: number): void {\n        writeString(value.toString());\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the serial port.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=serial/write-value blockHidden=true\n    //% blockId=serial_writevalue block=\"serial|write value %name|= %value\"\n    export function writeValue(name: string, value: number): void {\n        const prefix = name ? name + \":\" : \"\";\n        serial.writeLine(prefix + value);\n    }\n\n}\n",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n\n    //% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\ndeclare interface Buffer {\n    /**\n     * Write a number in specified format in the buffer.\n     */\n    //% shim=BufferMethods::setNumber\n    setNumber(format: NumberFormat, offset: int32, value: number): void;\n\n    /**\n     * Read a number in specified format from the buffer.\n     */\n    //% shim=BufferMethods::getNumber\n    getNumber(format: NumberFormat, offset: int32): number;\n\n    /** Returns the length of a Buffer object. */\n    //% property shim=BufferMethods::length\n    length: int32;\n\n    /**\n     * Fill (a fragment) of the buffer with given value.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::fill\n    fill(value: int32, offset?: int32, length?: int32): void;\n\n    /**\n     * Return a copy of a fragment of a buffer.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::slice\n    slice(offset?: int32, length?: int32): Buffer;\n\n    /**\n     * Shift buffer left in place, with zero padding.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::shift\n    shift(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Convert a buffer to its hexadecimal representation.\n     */\n    //% shim=BufferMethods::toHex\n    toHex(): string;\n\n    /**\n     * Rotate buffer left in place.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::rotate\n    rotate(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Write contents of `src` at `dstOffset` in current buffer.\n     */\n    //% shim=BufferMethods::write\n    write(dstOffset: int32, src: Buffer): void;\n}\ndeclare namespace loops {\n\n    /**\n     * Repeats the code forever in the background. On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    //% help=loops/forever weight=100 afterOnStart=true\n    //% blockId=forever block=\"forever\" blockAllowMultiple=1 shim=loops::forever\n    function forever(a: () => void): void;\n\n    /**\n     * Pause for the specified time in milliseconds\n     * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n     */\n    //% help=loops/pause weight=99\n    //% async block=\"pause %pause=timePicker|ms\"\n    //% blockId=device_pause shim=loops::pause\n    function pause(ms: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Gets the number of milliseconds elapsed since power on.\n     */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\" shim=control::millis\n    function millis(): int32;\n\n    /**\n     * Run code when a registered event happens.\n     * @param id the event compoent id\n     * @param value the event value to match\n     */\n    //% weight=20 blockGap=8 blockId=\"control_on_event\" block=\"on event|from %src|with value %value\"\n    //% blockExternalInputs=1\n    //% help=\"control/on-event\" flags.defl=16 shim=control::onEvent\n    function onEvent(src: int32, value: int32, handler: () => void, flags?: int32): void;\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\" shim=control::reset\n    function reset(): void;\n\n    /**\n     * Block the current fiber for the given microseconds\n     * @param micros number of micro-seconds to wait. eg: 4\n     */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (s)%micros\" shim=control::waitMicros\n    function waitMicros(micros: int32): void;\n\n    /**\n     * Run other code in the background.\n     */\n    //% help=control/run-in-background blockAllowMultiple=1 afterOnStart=true\n    //% blockId=\"control_run_in_background\" block=\"run in background\" blockGap=8 shim=control::runInBackground\n    function runInBackground(a: () => void): void;\n\n    /**\n     * Blocks the calling thread until the specified event is raised.\n     */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\" shim=control::waitForEvent\n    function waitForEvent(src: int32, value: int32): void;\n\n    /**\n     * Derive a unique, consistent serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number shim=control::deviceSerialNumber\n    function deviceSerialNumber(): int32;\n}\ndeclare namespace serial {\n\n    /**\n     * Write some text to the serial port.\n     */\n    //% help=serial/write-string\n    //% weight=87 blockHidden=true\n    //% blockId=serial_writestring block=\"serial|write string %text\" shim=serial::writeString\n    function writeString(text: string): void;\n\n    /**\n     * Send a buffer across the serial connection.\n     */\n    //% help=serial/write-buffer weight=6 blockHidden=true\n    //% blockId=serial_writebuffer block=\"serial|write buffer %buffer\" shim=serial::writeBuffer\n    function writeBuffer(buffer: Buffer): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nloops.forever(() => {\n    loops.pause(100)\n})\n"
    },
    "core": {
      "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
      "codal.cpp": "#include \"pxt.h\"\n#include \"neopixel.h\"\n\nvoid cpu_clock_init(void);\n\nnamespace pxt {\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\n// TODO: these make platform device assumptions - should be lifted out\nCodalUSB usb;\nHF2 hf2;\ncodal::mbed::Timer devTimer;\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\n// TODO extract these from uf2_info()?\nstatic const char *string_descriptors[] = {\n    \"Example Corp.\", \"PXT Device\", \"42424242\",\n};\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb.stringDescriptors = string_descriptors;\n    usb.add(hf2);\n    usb.start();\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    if (curr)\n        runAction1(curr->action, fromInt(e.value));\n\n    curr = findBinding(e.source, DEVICE_EVT_ANY);\n    if (curr)\n        runAction1(curr->action, fromInt(e.value));\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event))\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    decr((Action)a);\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        incr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInBackground(Action a) {\n    if (a != 0) {\n        incr(a);\n        create_fiber((void (*)(void *))runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRandomSeed() {\n    int seed = 0xC0DA1;\n    auto pinTemp = LOOKUP_PIN(TEMPERATURE);\n    if (pinTemp)\n        seed *= pinTemp->getAnalogValue();\n    auto pinLight = LOOKUP_PIN(LIGHT);\n    if (pinLight)\n        seed *= pinLight->getAnalogValue();\n    seedRandom(seed);\n}\n\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n}\n\nvoid clearNeoPixels() {\n    // clear on-board neopixels\n    auto neoPin = LOOKUP_PIN(NEOPIXEL);\n    if (neoPin) {\n        int numNeopixels = getConfig(CFG_NUM_NEOPIXELS, 0);\n        int size = numNeopixels * 3;\n        if (size) {\n            uint8_t neobuf[size];\n            memset(neobuf, 0, size);\n            neoPin->setDigitalValue(0);\n            fiber_sleep(1);\n            neopixel_send_buffer(*neoPin, neobuf, 30);\n        }\n    }\n}\n\nvoid initRuntime() {\n    initCodal();\n    initSwdPins();\n    initRandomSeed();\n    clearNeoPixels();\n\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nvoid dumpDmesg() {\n    hf2.sendSerial(\"\\nDMESG:\\n\", 8);\n    hf2.sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    hf2.sendSerial(\"\\n\\n\", 2);\n}\n\nvoid sendSerial(const char *data, int len) {\n    hf2.sendSerial(data, len);\n}\n\nint getSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n}\n",
      "control.cpp": "#include \"pxt.h\"\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n}\n",
      "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // built/codal/libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_L = 1,\n    DEVICE_ID_BUTTON_R = 2,\n    DEVICE_ID_BUTTON_U = 3,\n    DEVICE_ID_BUTTON_D = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // built/codal/libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // built/codal/libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // built/codal/libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    // built/codal/libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // built/codal/libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/CodalUSB.h\n    GET_STATUS = 0,\n    CLEAR_FEATURE = 1,\n    SET_FEATURE = 3,\n    SET_ADDRESS = 5,\n    GET_DESCRIPTOR = 6,\n    SET_DESCRIPTOR = 7,\n    GET_CONFIGURATION = 8,\n    SET_CONFIGURATION = 9,\n    GET_INTERFACE = 10,\n    SET_INTERFACE = 11,\n    SYNCH_FRAME = 12,\n    DIRECTION_OUT = 0,\n    DIRECTION_IN = 1,\n    DEVICE_REMOTE_WAKEUP = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // built/codal/libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // built/codal/libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_RX_IN_USE = 1,\n    CODAL_SERIAL_TX_IN_USE = 2,\n    CODAL_SERIAL_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_TX_BUFF_INIT = 8,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // built/codal/libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // built/codal/libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // built/codal/libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // built/codal/libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // built/codal/libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // built/codal/libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // built/codal/libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // built/codal/libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // built/codal/libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // built/codal/libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // built/codal/libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // built/codal/libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // built/codal/libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // built/codal/libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // built/codal/libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // built/codal/pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // built/codal/pxtapp/pins.h\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    DEV_NUM_PINS = 64,\n    Click = 3,\n    LongClick = 4,\n    // built/codal/pxtapp/pxt.h\n    PAGE_SIZE = 256,\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // built/codal/pxtapp/pxtbase.h\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    // built/codal/pxtapp/pxtconfig.h\n    PXT_VM = 0,\n    // built/codal/pxtapp/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // built/codal/pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
      "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\nSINGLETON(WDMAC);\n\n}",
      "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n#include \"SAMD21DAC.h\"\n\nnamespace pxt {\n\nclass WDMAC {\n  public:\n    SAMD21DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n\n}\n\n#endif",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "hf2.cpp": "#define UF2_DEFINE_HANDOVER 1\n#include \"pxt.h\"\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfo = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x00, //\n        0x00, //\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup)\n{\n    if (setup.bRequest == GET_DESCRIPTOR)\n    {\n        if (setup.wValueH == 0x21)\n        {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        }\n        else if (setup.wValueH == 0x22)\n        {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n    return DEVICE_NOT_SUPPORTED;\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo()\n{\n    return &ifaceInfo;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError)\n{\n    return send(data, size, isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT);\n}\n\n// Recieve HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n    int len = out->read(buf, sizeof(buf));\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\n// Send HF2 message.\n// Use command message when flag == HF2_FLAG_CMDPKT_LAST\n// Use serial stdout for HF2_FLAG_SERIAL_OUT and stderr for HF2_FLAG_SERIAL_ERR.\nint HF2::send(const void *data, int size, int flag0) {\n    uint8_t buf[64];\n    const uint8_t *ptr = (const uint8_t *)data;\n\n    if (!CodalUSB::usbInstance->isInitialised())\n        return -1;\n\n    for (;;) {\n        int s = 63;\n        int flag = flag0;\n        if (size <= 63) {\n            s = size;\n        } else {\n            if (flag == HF2_FLAG_CMDPKT_LAST)\n                flag = HF2_FLAG_CMDPKT_BODY;\n        }\n        buf[0] = flag | s;\n        memcpy(buf + 1, ptr, s);\n        if (in->write(buf, sizeof(buf)) < 0)\n            return -1;\n        ptr += s;\n        size -= s;\n        if (!size)\n            break;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    return send(pkt.buf, 4 + size, HF2_FLAG_CMDPKT_LAST);\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    int res;\n\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        __disable_irq();\n        memcpy(pkt.resp.data8, data, size);\n        __enable_irq();\n        res = sendResponse(size);\n    } else {\n        __disable_irq();\n        send(pkt.buf, 4, HF2_FLAG_CMDPKT_BODY);\n        res = send(data, size, HF2_FLAG_CMDPKT_LAST);\n        __enable_irq();\n    }\n\n    return res;\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n\nint HF2::endpointRequest()\n{\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        *DBL_TAP_PTR = DBL_TAP_MAGIC_QUICK_BOOT;\n        // fall-through\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        target_reset();\n        break;\n\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2() : USBHID() {}\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n    \n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        free(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            free(stackCopy);\n        stackCopy = malloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n",
      "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n#define HF2_BUF_SIZE 256\n\ntypedef struct\n{\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public codal::USBHID\n{\npublic:\n    HF2_Buffer pkt;\n    int sendResponse(int size);\n    int send(const void *data, int size, int flag);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n\n    HF2();\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup& setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n\n    int sendSerial(const void *data, int size, int isError = 0);\n};\n\n#endif\n",
      "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
      "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n    static codal::I2C *i2c;\n\n    static void initI2C() {\n      if (i2c == NULL) {\n        i2c = new codal::mbed::I2C(*LOOKUP_PIN(SDA), *LOOKUP_PIN(SCL));\n      }\n    }\n\n      /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    Buffer i2cReadBuffer(int address, int size, bool repeat = false)\n    {\n      initI2C();\n      Buffer buf = createBuffer(size);\n      int status = i2c->read(address << 1, buf->data, size, repeat);\n      if (status != ErrorCode::DEVICE_OK) {\n        free(buf);\n        buf = 0;\n      }\n      return buf;\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    int i2cWriteBuffer(int address, Buffer buf, bool repeat = false)\n    {\n      initI2C();\n      return i2c->write(address << 1, buf->data, buf->length, repeat);\n    }\n}",
      "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format=i2c_sizeof|repeated %repeat\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        let buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format=i2c_sizeof|repeated %repeat\"\n    export function i2cWriteNumber(address: number, value: number, format: NumberFormat, repeated?: boolean): void {\n        let buf = createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    export class I2CDevice {\n        public address: number;\n        private _hasError: boolean;\n        constructor(address: number) {\n            this.address = address\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = i2cReadBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = i2cWriteBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin() {\n            this._hasError = false\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n    }\n}",
      "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}",
      "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\n    static DevicePin **pinPtrs;\n    static uint8_t numPinPtrs;\n    static uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n    if (id < 0 || id >= DEV_NUM_PINS)\n        target_panic(42);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void*));\n        bool isAnalog = (DEV_ANALOG_PINS >> id) & 1;\n        pinPtrs[numPinPtrs++] = new DevicePin(\n            DEVICE_ID_IO_P0 + id,\n            (PinName)id,\n            isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(42);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0) return NULL;\n    return getPin(pinName);\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n}\n\nnamespace pins {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n* Get the duration of the last pulse in microseconds. This function should be called from a\n* ``onPulsed`` handler.\n*/\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n}\n",
      "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// Analog Pins, all SAMD21: PA02-PA11 PB00-PB09 (some pins not connected)\n// 2 ports times 32 pins in each\n#define DEV_NUM_PINS 64\n// pins marked with AIN and PTC in the data sheet\n#define DEV_ANALOG_PINS 0x3ff00000ffcULL\n\ntypedef codal::mbed::Pin DevicePin;\n\ntypedef DevicePin *DigitalPin;\ntypedef DevicePin *AnalogPin;\ntypedef DevicePin *PwmPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *lookupPin(int pinName);\nvoid linkPin(int from, int to);\nButton *getButtonByPin(int pin, int flags);\nAbstractButton *getButton(int id);\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
      "pins.ts": "/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n    /**\n     * Get the size in bytes of specified number format.\n     */\n    //%\n    export function sizeOf(format: NumberFormat) {\n        switch (format) {\n            case NumberFormat.Int8LE:\n            case NumberFormat.UInt8LE:\n            case NumberFormat.Int8BE:\n            case NumberFormat.UInt8BE:\n                return 1;\n            case NumberFormat.Int16LE:\n            case NumberFormat.UInt16LE:\n            case NumberFormat.Int16BE:\n            case NumberFormat.UInt16BE:\n                return 2;\n            case NumberFormat.Int32LE:\n            case NumberFormat.Int32BE:\n            case NumberFormat.UInt32BE:\n            case NumberFormat.UInt32LE:\n            case NumberFormat.Float32BE:\n            case NumberFormat.Float32LE:\n                return 4;\n            case NumberFormat.Float64BE:\n            case NumberFormat.Float64LE:\n                return 8;\n        }\n        return 0;\n    }\n\n    /**\n     * Create a new buffer initalized to bytes from given array.\n     * @param bytes data to initalize with\n     */\n    //%\n    export function createBufferFromArray(bytes: number[]) {\n        let buf = createBuffer(bytes.length)\n        for (let i = 0; i < bytes.length; ++i)\n            buf[i] = bytes[i]\n        return buf\n    }\n\n    function getFormat(pychar: string, isBig: boolean) {\n        switch (pychar) {\n            case 'B':\n                return NumberFormat.UInt8LE\n            case 'b':\n                return NumberFormat.Int8LE\n            case 'H':\n                return isBig ? NumberFormat.UInt16BE : NumberFormat.UInt16LE\n            case 'h':\n                return isBig ? NumberFormat.Int16BE : NumberFormat.Int16LE\n            case 'I':\n            case 'L':\n                return isBig ? NumberFormat.UInt32BE : NumberFormat.UInt32LE\n            case 'i':\n            case 'l':\n                return isBig ? NumberFormat.Int32BE : NumberFormat.Int32LE\n            case 'f':\n                return isBig ? NumberFormat.Float32BE : NumberFormat.Float32LE\n            case 'd':\n                return isBig ? NumberFormat.Float64BE : NumberFormat.Float64LE\n            default:\n                return null as NumberFormat\n        }\n    }\n\n    function packUnpackCore(format: string, nums: number[], buf: Buffer, isPack: boolean, off = 0) {\n        let isBig = false\n        let idx = 0\n        for (let i = 0; i < format.length; ++i) {\n            switch (format[i]) {\n                case ' ':\n                case '<':\n                case '=':\n                    isBig = false\n                    break\n                case '>':\n                case '!':\n                    isBig = true\n                    break\n                case 'x':\n                    off++\n                    break\n                default:\n                    let fmt = getFormat(format[i], isBig)\n                    if (fmt === null) {\n                        control.fail(\"Not supported format character: \" + format[i])\n                    } else {\n                        if (buf) {\n                            if (isPack)\n                                buf.setNumber(fmt, off, nums[idx++])\n                            else\n                                nums.push(buf.getNumber(fmt, off))\n                        }\n\n                        off += pins.sizeOf(fmt)\n                    }\n                    break\n            }\n        }\n        return off\n    }\n\n    export function packedSize(format: string) {\n        return packUnpackCore(format, null, null, true)\n    }\n\n    export function packBuffer(format: string, nums: number[]) {\n        let buf = createBuffer(packedSize(format))\n        packUnpackCore(format, nums, buf, true)\n        return buf\n    }\n\n    export function packIntoBuffer(format: string, buf: Buffer, offset: number, nums: number[]) {\n        packUnpackCore(format, nums, buf, true, offset)\n    }\n\n    export function unpackBuffer(format: string, buf: Buffer, offset = 0) {\n        let res: number[] = []\n        packUnpackCore(format, res, buf, false, offset)\n        return res\n    }\n}\n\n// see http://msgpack.org/ for the spec\n// it currently only implements numbers and their sequances\n// once we handle any type and typeof expressions we can do more\n\nnamespace msgpack {\n    function tagFormat(tag: number) {\n        switch (tag) {\n            case 0xCB: return NumberFormat.Float64BE\n            case 0xCC: return NumberFormat.UInt8BE\n            case 0xCD: return NumberFormat.UInt16BE\n            case 0xCE: return NumberFormat.UInt32BE\n            case 0xD0: return NumberFormat.Int8BE\n            case 0xD1: return NumberFormat.Int16BE\n            case 0xD2: return NumberFormat.Int32BE\n            default:\n                return null\n        }\n    }\n\n    function packNumberCore(buf: Buffer, offset: number, num: number) {\n        let tag = 0xCB\n        if (num == (num << 0) || num == (num >>> 0)) {\n            if (-31 <= num && num <= 127) {\n                if (buf) buf[offset] = num\n                return 1\n            } else if (0 <= num) {\n                if (num <= 0xff) {\n                    tag = 0xCC\n                } else if (num <= 0xffff) {\n                    tag = 0xCD\n                } else {\n                    tag = 0xCE\n                }\n            } else {\n                if (-0x7f <= num) {\n                    tag = 0xD0\n                } else if (-0x7fff <= num) {\n                    tag = 0xD1\n                } else {\n                    tag = 0xD2\n                }\n            }\n        }\n        let fmt = tagFormat(tag)\n        if (buf) {\n            buf[offset] = tag\n            buf.setNumber(fmt, offset + 1, num)\n        }\n        return pins.sizeOf(fmt) + 1\n    }\n\n    /**\n     * Unpacks a buffer into a number array.\n     */\n    export function unpackNumberArray(buf: Buffer, offset = 0): number[] {\n        let res: number[] = []\n\n        while (offset < buf.length) {\n            let fmt = tagFormat(buf[offset++])\n            if (fmt === null) {\n                let v = buf.getNumber(NumberFormat.Int8BE, offset - 1)\n                if (-31 <= v && v <= 127)\n                    res.push(v)\n                else\n                    return null\n            } else {\n                res.push(buf.getNumber(fmt, offset))\n                offset += pins.sizeOf(fmt)\n            }\n            // padding at the end\n            while (buf[offset] === 0xc1) offset++;\n        }\n\n        return res\n    }\n\n    /**\n     * Pack a number array into a buffer.\n     * @param nums the numbers to be packed\n     */\n    export function packNumberArray(nums: number[]): Buffer {\n        let off = 0\n        for (let n of nums) {\n            off += packNumberCore(null, off, n)\n        }\n        let buf = pins.createBuffer(off)\n        off = 0\n        for (let n of nums) {\n            off += packNumberCore(buf, off, n)\n        }\n        return buf\n    }\n}\n\n\n//% noRefCounting fixedInstances\ninterface DigitalPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogPin extends DigitalPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends AnalogPin {\n    // methods filled from C++\n}\n\ninterface Buffer {\n    [index: number]: number;\n    // rest defined in buffer.cpp\n}",
      "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogPin name) {\n    return PINOP(getAnalogValue());\n}\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogWrite(AnalogPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
      "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% parts=\"slideswitch\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value\"\n//% parts=\"led\" trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nvoid onPulsed(DigitalPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %value\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = value == PulseValue::High ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}",
      "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed, eg:180,90,0\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoWrite(PwmPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n}",
      "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n#undef DMESG\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n#include \"CapTouchButton.h\"\n#include \"Image.h\"\n#include \"MbedTimer.h\"\n#include \"MbedI2C.h\"\n#include \"MbedPin.h\"\n#include \"MultiButton.h\"\n\nusing namespace codal;\n\n#include \"pins.h\"\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n\n#define PAGE_SIZE 256\n\nnamespace pxt {\n\nextern CodalUSB usb;\nextern HF2 hf2;\n\n// Utility functions\nextern Event lastEvent;\nextern codal::mbed::Timer devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n}\n\n#define DEVICE_ID_BUTTON_SLIDE  3000\n#define DEVICE_ID_MICROPHONE    3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#endif\n\n#endif\n",
      "pxt.json": "{\n  \"name\": \"core\",\n  \"description\": \"The core library for Codal-based targets\",\n  \"files\": [\n    \"README.md\",\n    \"dal.d.ts\",\n    \"codal.cpp\",\n    \"pxt.h\",\n    \"pxtcore.h\",\n    \"pins.h\",\n    \"pins.cpp\",\n    \"pinsAnalog.cpp\",\n    \"pinsDigital.cpp\",\n    \"pinsPWM.cpp\",\n    \"pins.ts\",\n    \"control.cpp\",\n    \"i2c.cpp\",\n    \"i2c.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"hf2.cpp\",\n    \"hf2.h\",\n    \"hf2dbg.h\",\n    \"uf2format.h\",\n    \"uf2hid.h\",\n    \"ns.ts\",\n    \"dmac.cpp\",\n    \"dmac.h\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"yotta\": {\n    \"config\": {\n      \"codal\": {\n        \"component_count\": 64,\n        \"dmesg_buffer_size\": 4096,\n        \"tag\": 1\n      }\n    }\n  },\n  \"public\": true,\n  \"dalDTS\": {\n    \"includeDirs\": [\n      \"libraries/codal-core/inc\",\n      \"pxtapp\"\n    ],\n    \"excludePrefix\": [\n      \"USB_\",\n      \"REQUEST_\",\n      \"LIS3DH_\",\n      \"FXOS8700_\",\n      \"HF2_\",\n      \"PXT_REF_TAG_\"\n    ]\n  },\n  \"dependencies\": {\n    \"base\": \"*\"\n  }\n}",
      "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\nvoid codal_dmesg(const char *format, ...);\n#define DMESG codal_dmesg\n\n#endif\n",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace pins {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogPinMethods::analogRead\n    analogRead(): int32;\n\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% parts=\"slideswitch\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value\"\n    //% parts=\"led\" trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 shim=DigitalPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %value\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed, eg:180,90,0\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmPinMethods::servoWrite\n    servoWrite(value: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cReadBuffer\n    function i2cReadBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=pins::i2cWriteBuffer\n    function i2cWriteBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\nloops.forever(() => {\n    loops.pause(100)\n})\n",
      "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n// if you increase that, you will also need to update the linker script file\n#define APP_START_ADDRESS 0x00002000\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\n#define UF2_BINFO ((UF2_BInfo *)(APP_START_ADDRESS - sizeof(UF2_BInfo)))\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return 0xb4 <= (uint32_t)addr && (uint32_t)addr < APP_START_ADDRESS;\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_BINFO->info_uf2))\n        return UF2_BINFO->info_uf2;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
      "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n\n#endif\n"
    },
    "buttons": {
      "README.md": "# buttons\n\nA library to handle 2 buttons A and B.\n",
      "buttons.cpp": "#include \"pxt.h\"\n\n/*\n\nThese button events need CODAL work.\n\n    // % block=\"double click\"\n    DoubleClick = DEVICE_BUTTON_EVT_DOUBLE_CLICK,\n\n    // % block=\"hold\"\n    Hold = DEVICE_BUTTON_EVT_HOLD\n\n*/\n\n/**\n* User interaction on buttons\n*/\nenum class ButtonEvent {\n    //% block=\"click\"\n    Click = DEVICE_BUTTON_EVT_CLICK,\n    //% block=\"long click\"\n    LongClick = DEVICE_BUTTON_EVT_LONG_CLICK,\n    //% block=\"up\"\n    Up = DEVICE_BUTTON_EVT_UP,\n    //% block=\"down\"\n    Down = DEVICE_BUTTON_EVT_DOWN\n};\n\nnamespace pxt {\n//%\nButton *getButtonByPin(int pin, int flags) {\n    auto cpid = DEVICE_ID_FIRST_BUTTON + pin;\n    auto btn = (Button *)lookupComponent(cpid);\n    if (btn == NULL) {\n        auto pull = PullMode::None;\n        if ((flags & 0xf0) == 0x10)\n            pull = PullMode::Down;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::Up;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::None;\n        else\n            target_panic(42);\n        btn = new Button(*lookupPin(pin), cpid, DEVICE_BUTTON_ALL_EVENTS,\n                         (ButtonPolarity)(flags & 0xf), pull);\n    }\n    return btn;\n}\n\n// This is for A, B, and AB\n//%\nAbstractButton *getButton(int id) {\n    int pa = getConfig(CFG_PIN_BTN_A);\n    int pb = getConfig(CFG_PIN_BTN_B);\n    int flags = getConfig(CFG_DEFAULT_BUTTON_MODE, BUTTON_ACTIVE_LOW_PULL_UP);\n    if (id == 0)\n        return getButtonByPin(pa, flags);\n    else if (id == 1)\n        return getButtonByPin(pb, flags);\n    else if (id == 2)\n        return getMultiButton(DEVICE_ID_BUTTON_AB, pa, pb, flags);\n    else {\n        target_panic(42);\n        return NULL;\n    }\n}\n\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags) {\n    auto btn = (MultiButton *)lookupComponent(id);\n    if (btn == NULL) {\n        auto bA = getButtonByPin(pinA, flags);\n        auto bB = getButtonByPin(pinB, flags);\n        btn = new codal::MultiButton(bA->id, bB->id, id);\n\n        // A user has registered to receive events from the buttonAB multibutton.\n        // Disable click events from being generated by ButtonA and ButtonB, and defer the\n        // control of this to the multibutton handler.\n        //\n        // This way, buttons look independent unless a buttonAB is requested, at which\n        // point button A+B clicks can be correclty handled without breaking\n        // causal ordering.\n        bA->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        bB->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        btn->setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);\n    }\n    return btn;\n}\n}\n\n\nnamespace DigitalPinMethods {\n\n/**\n * Get the push button (connected to GND) for given pin\n */\n//%\nButton_ pushButton(DigitalPin pin) {\n    return pxt::getButtonByPin(pin->name, BUTTON_ACTIVE_LOW_PULL_UP);\n}\n\n}\n\n\n//% noRefCounting fixedInstances\nnamespace ButtonMethods {\n/**\n * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n * @param button the button that needs to be clicked or used\n * @param event the kind of button gesture that needs to be detected\n * @param body code to run when the event is raised\n */\n//% help=input/button/on-event\n//% blockId=buttonEvent block=\"on %button|%event\"\n//% parts=\"buttons\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=96 blockGap=12\n//% trackArgs=0\nvoid onEvent(Button_ button, ButtonEvent ev, Action body) {\n    registerWithDal(button->id, (int)ev, body);\n}\n\n/**\n * Check if a button is pressed or not.\n * @param button the button to query the request\n */\n//% help=input/button/is-pressed\n//% block=\"%button|is pressed\"\n//% blockId=buttonIsPressed\n//% parts=\"buttons\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=50 blockGap=8\n//% trackArgs=0\nbool isPressed(Button_ button) {\n    return button->isPressed();\n}\n\n/**\n * See if the button was pressed again since the last time you checked.\n * @param button the button to query the request\n */\n//% help=input/button/was-pressed\n//% block=\"%button|was pressed\"\n//% blockId=buttonWasPressed\n//% parts=\"buttons\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% group=\"More\" weight=46 blockGap=8\n//% trackArgs=0\nbool wasPressed(Button_ button) {\n    return button->wasPressed();\n}\n}\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    /**\n     * User interaction on buttons\n     */\n\n    declare const enum ButtonEvent {\n    //% block=\"click\"\n    Click = 3,  // DEVICE_BUTTON_EVT_CLICK\n    //% block=\"long click\"\n    LongClick = 4,  // DEVICE_BUTTON_EVT_LONG_CLICK\n    //% block=\"up\"\n    Up = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"down\"\n    Down = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "pxt.json": "{\n  \"name\": \"buttons\",\n  \"description\": \"Button A and B drivers\",\n  \"files\": [\n    \"README.md\",\n    \"buttons.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface DigitalPin {\n    /**\n     * Get the push button (connected to GND) for given pin\n     */\n    //% shim=DigitalPinMethods::pushButton\n    pushButton(): Button;\n}\n\n\n\n    //% noRefCounting fixedInstances\ndeclare interface Button {\n    /**\n     * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n     * @param button the button that needs to be clicked or used\n     * @param event the kind of button gesture that needs to be detected\n     * @param body code to run when the event is raised\n     */\n    //% help=input/button/on-event\n    //% blockId=buttonEvent block=\"on %button|%event\"\n    //% parts=\"buttons\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=96 blockGap=12\n    //% trackArgs=0 shim=ButtonMethods::onEvent\n    onEvent(ev: ButtonEvent, body: () => void): void;\n\n    /**\n     * Check if a button is pressed or not.\n     * @param button the button to query the request\n     */\n    //% help=input/button/is-pressed\n    //% block=\"%button|is pressed\"\n    //% blockId=buttonIsPressed\n    //% parts=\"buttons\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=50 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::isPressed\n    isPressed(): boolean;\n\n    /**\n     * See if the button was pressed again since the last time you checked.\n     * @param button the button to query the request\n     */\n    //% help=input/button/was-pressed\n    //% block=\"%button|was pressed\"\n    //% blockId=buttonWasPressed\n    //% parts=\"buttons\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% group=\"More\" weight=46 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::wasPressed\n    wasPressed(): boolean;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": ""
    },
    "accelerometer": {
      "README.md": "# accelerometer\n\nThe accelerometer library.\n\n",
      "accelerometer.cpp": "#include \"pxt.h\"\n#include \"axis.h\"\n#include \"Pin.h\"\n#include \"I2C.h\"\n#include \"CoordinateSystem.h\"\n#include \"LIS3DH.h\"\n\nenum class Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n};\n\nenum class Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n};\n\nenum class AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8\n};\n\nenum class Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = ACCELEROMETER_EVT_SHAKE,\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = ACCELEROMETER_EVT_TILT_UP,\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = ACCELEROMETER_EVT_TILT_DOWN,\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = ACCELEROMETER_EVT_TILT_LEFT,\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = ACCELEROMETER_EVT_TILT_RIGHT,\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = ACCELEROMETER_EVT_FACE_UP,\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = ACCELEROMETER_EVT_FACE_DOWN,\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = ACCELEROMETER_EVT_FREEFALL,\n    /**\n    * Raised when a 3G shock is detected\n    */\n    //% block=\"3g\"\n    ThreeG = ACCELEROMETER_EVT_3G,\n    /**\n    * Raised when a 6G shock is detected\n    */\n    //% block=\"6g\"\n    SixG = ACCELEROMETER_EVT_6G,\n    /**\n    * Raised when a 8G shock is detected\n    */\n    //% block=\"8g\"\n    EightG = ACCELEROMETER_EVT_8G\n};\n\nnamespace pxt {\n\n// Wrapper classes\n\nclass WAccel {\n  public:\n    codal::mbed::I2C i2c; // note that this is different pins than io->i2c\n    CoordinateSpace space;\n    LIS3DH acc;\n    WAccel()\n        : i2c(*LOOKUP_PIN(ACCELEROMETER_SDA), *LOOKUP_PIN(ACCELEROMETER_SCL)),\n          space(ACC_SYSTEM, ACC_UPSIDEDOWN, ACC_ROTATION),\n          acc(i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space) //\n    {\n        acc.init();        \n    }\n};\nSINGLETON(WAccel);\n}\n\nnamespace input {\n/**\n * Do something when when a gesture is done (like shaking the board).\n * @param gesture the type of gesture to track, eg: Gesture.Shake\n * @param body code to run when gesture is raised\n */\n//% help=input/on-gesture\n//% blockId=device_gesture_event block=\"on |%NAME\"\n//% parts=\"accelerometer\"\n//% gesture.fieldEditor=\"gridpicker\"\n//% gesture.fieldOptions.width=220\n//% gesture.fieldOptions.columns=3\n//% weight=92 blockGap=12\nvoid onGesture(Gesture gesture, Action body) {\n    auto acc = &getWAccel()->acc;\n    acc->updateSample();\n    int gi = (int)gesture;\n    if (gi == ACCELEROMETER_EVT_3G && acc->getRange() < 3)\n        acc->setRange(4);\n    else if ((gi == ACCELEROMETER_EVT_6G || gi == ACCELEROMETER_EVT_8G) && acc->getRange() < 6)\n        acc->setRange(8);\n    registerWithDal(DEVICE_ID_GESTURE, gi, body);\n}\n\nint getAccelerationStrength() {\n    auto acc = &getWAccel()->acc;\n    float x = acc->getX();\n    float y = acc->getY();\n    float z = acc->getZ();\n    return (int)sqrtf(x * x + y * y + z * z);\n}\n\n/**\n * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n * x=0, y=0 and z=-1023)\n * @param dimension TODO\n */\n//% help=input/acceleration\n//% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n//% parts=\"accelerometer\"\n//% dimension.fieldEditor=\"gridpicker\"\n//% dimension.fieldOptions.width=180\n//% dimension.fieldOptions.columns=2\n//% weight=42 blockGap=8\nint acceleration(Dimension dimension) {\n    switch (dimension) {\n    case Dimension::X:\n        return getWAccel()->acc.getX();\n    case Dimension::Y:\n        return getWAccel()->acc.getY();\n    case Dimension::Z:\n        return getWAccel()->acc.getZ();\n    case Dimension::Strength:\n        return getAccelerationStrength();\n    }\n    return 0;\n}\n\n/**\n * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n * @param kind TODO\n */\n//% help=input/rotation\n//% blockId=device_get_rotation block=\"rotation ()|%NAME\"\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=38\nint rotation(Rotation kind) {\n    switch (kind) {\n    case Rotation::Pitch:\n        return getWAccel()->acc.getPitch();\n    case Rotation::Roll:\n        return getWAccel()->acc.getRoll();\n    }\n    return 0;\n}\n\n/**\n * Sets the accelerometer sample range in gravities.\n * @param range a value describe the maximum strengh of acceleration measured\n */\n//% help=input/set-accelerometer-range\n//% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n//% weight=5\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=15 blockGap=8\nvoid setAccelerometerRange(AcceleratorRange range) {\n    getWAccel()->acc.setRange((int)range);\n}\n\n}\n",
      "axis.h": "// Override in target to change inversion of axis\n\n#define ACC_SYSTEM NORTH_EAST_UP\n#define ACC_UPSIDEDOWN true\n#define ACC_ROTATION COORDINATE_SPACE_ROTATED_0\n\n/*\n                        X  Y  Z\nLaying flat:            0  0 -1\nStanding normally:      0  1  0\nStanding on left side: -1  0  0\n*/\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n    }\n\n\n    declare const enum Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n    }\n\n\n    declare const enum AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8,\n    }\n\n\n    declare const enum Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = 11,  // ACCELEROMETER_EVT_SHAKE\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = 1,  // ACCELEROMETER_EVT_TILT_UP\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = 2,  // ACCELEROMETER_EVT_TILT_DOWN\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = 3,  // ACCELEROMETER_EVT_TILT_LEFT\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = 4,  // ACCELEROMETER_EVT_TILT_RIGHT\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = 5,  // ACCELEROMETER_EVT_FACE_UP\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = 6,  // ACCELEROMETER_EVT_FACE_DOWN\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = 7,  // ACCELEROMETER_EVT_FREEFALL\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = 8,  // ACCELEROMETER_EVT_3G\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = 9,  // ACCELEROMETER_EVT_6G\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = 10,  // ACCELEROMETER_EVT_8G\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
      "pxt.json": "{\n  \"name\": \"accelerometer\",\n  \"description\": \"The accelerometer library\",\n  \"files\": [\n    \"README.md\",\n    \"accelerometer.cpp\",\n    \"axis.h\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Do something when when a gesture is done (like shaking the board).\n     * @param gesture the type of gesture to track, eg: Gesture.Shake\n     * @param body code to run when gesture is raised\n     */\n    //% help=input/on-gesture\n    //% blockId=device_gesture_event block=\"on |%NAME\"\n    //% parts=\"accelerometer\"\n    //% gesture.fieldEditor=\"gridpicker\"\n    //% gesture.fieldOptions.width=220\n    //% gesture.fieldOptions.columns=3\n    //% weight=92 blockGap=12 shim=input::onGesture\n    function onGesture(gesture: Gesture, body: () => void): void;\n\n    /**\n     * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n     * x=0, y=0 and z=-1023)\n     * @param dimension TODO\n     */\n    //% help=input/acceleration\n    //% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% dimension.fieldEditor=\"gridpicker\"\n    //% dimension.fieldOptions.width=180\n    //% dimension.fieldOptions.columns=2\n    //% weight=42 blockGap=8 shim=input::acceleration\n    function acceleration(dimension: Dimension): int32;\n\n    /**\n     * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n     * @param kind TODO\n     */\n    //% help=input/rotation\n    //% blockId=device_get_rotation block=\"rotation ()|%NAME\"\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=38 shim=input::rotation\n    function rotation(kind: Rotation): int32;\n\n    /**\n     * Sets the accelerometer sample range in gravities.\n     * @param range a value describe the maximum strengh of acceleration measured\n     */\n    //% help=input/set-accelerometer-range\n    //% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n    //% weight=5\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=15 blockGap=8 shim=input::setAccelerometerRange\n    function setAccelerometerRange(range: AcceleratorRange): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": ""
    },
    "music": {
      "README.md": "# music\n\nThe music library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "melodies.ts": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 The MicroPython-on-micro:bit Developers, as listed\nin the accompanying AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// Melodies from file microbitmusictunes.c https://github.com/bbcmicrobit/MicroPython\n\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    let _soundQueue: control.AnimationQueue;\n\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    function soundQueue(): control.AnimationQueue {\n        if (!_soundQueue) _soundQueue = new control.AnimationQueue();\n        return _soundQueue;\n    }\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play, eg: music.sounds(Sounds.PowerUp)\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    export function playSound(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        control.runInBackground(() => {\n            queue.cancel();\n            queue.runUntilDone(() => melody.playNextNote());\n        })\n        loops.pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play, eg: music.sounds(Sounds.PowerUp)\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    export function playSoundUntilDone(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        queue.runUntilDone(() => melody.playNextNote());\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=93\n    export function stopAllSounds() {\n        const queue = soundQueue();\n        queue.cancel();\n        music.rest(1);\n    }\n\n    class Melody {\n        static freqTable: number[];\n        notes: string;\n        duration: number;\n        octave: number;\n        pos: number;\n        tempo: number;\n\n        constructor(notes: string) {\n            this.notes = notes;\n            this.duration = 4; //Default duration (Crotchet)\n            this.octave = 4; //Middle octave\n            this.pos = 0;\n            this.tempo = 120; // default tempo\n            // TODO: use HEX literal\n            if (!Melody.freqTable)\n                Melody.freqTable = [31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 92, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902]\n        }\n\n        hasNextNote() {\n            return this.pos < this.notes.length;\n        }\n\n        scanNextNote(): string {\n            // eat space\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                    break;\n                this.pos++;\n            }\n\n            // read note\n            let note = \"\";\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                    break;\n                note += c;\n                this.pos++;\n            }\n            return note;\n        }\n\n        playNextNote(): boolean {\n            let currNote = this.scanNextNote();\n            if (!currNote)\n                return false;\n\n            enum Token {\n                Note = 0,\n                Octave = 1,\n                Beat = 2,\n                Tempo = 3\n            }\n\n            let note: number = 0;\n            let isrest: boolean = false;\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: this.octave = d; break;\n                        case Token.Beat: this.duration = Math.max(1, Math.min(16, d)); break;\n                        case Token.Tempo: this.tempo = Math.max(1, d); break;\n                    }\n                    token = \"\";\n                }\n            }\n            for (let i = 0; i < currNote.length; i++) {\n                let noteChar = currNote.charAt(i);\n                switch (noteChar) {\n                    case 'c': case 'C': note = 1; break;\n                    case 'd': case 'D': note = 3; break;\n                    case 'e': case 'E': note = 5; break;\n                    case 'f': case 'F': note = 6; break;\n                    case 'g': case 'G': note = 8; break;\n                    case 'a': case 'A': note = 10; break;\n                    case 'b': case 'B': note = 12; break;\n                    case 'r': case 'R': isrest = true; break;\n                    case '#': note++; break;\n                    case 'b': note--; break;\n                    case ':':\n                        consumeToken();\n                        tokenKind = Token.Beat;\n                        break;\n                    case '-':\n                        consumeToken();\n                        tokenKind = Token.Tempo;\n                        break;\n                    default:\n                        if(tokenKind == Token.Note)\n                            tokenKind = Token.Octave;\n                        token += noteChar;\n                        break;\n                }\n            }\n            consumeToken();\n            let beat = 15000 / this.tempo;\n            if (isrest) {\n                music.rest(this.duration * beat)\n            } else {\n                const keyNumber = note + (12 * (this.octave - 1));\n                const frequency = Melody.freqTable[keyNumber] || 0;\n                music.playTone(frequency, this.duration * beat);\n            }\n\n            return this.hasNextNote();\n        }\n    }\n}",
      "music.cpp": "#include \"pxt.h\"\n\n#include \"dmac.h\"\n#include \"SAMD21DAC.h\"\n#include \"Synthesizer.h\"\n#include \"CodalConfig.h\"\n\n#define NOTE_PAUSE 20\nclass WSynthesizer {\n  public:\n    Synthesizer synth;\n    SAMD21DAC dac;\n\n    WSynthesizer()\n        // DAC always on PA02 on SAMD21\n        : dac(*lookupPin(PA02), pxt::getWDMAC()->dmac, synth.output) {\n        synth.setSampleRate(dac.getSampleRate());\n        synth.setVolume(64);\n    }\n};\nSINGLETON(WSynthesizer);\n\nenum class SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n};\n\nnamespace music {\n\nBuffer tone; // empty buffer to hold custom tone\nSoundOutputDestination soundOutputDestination = SoundOutputDestination::Speaker;\n\n// turns on/off the speaker amp\nvoid updateSpeakerAmp() {\n    // turn off speaker as needed\n    //auto pinAmp = LOOKUP_PIN(SPEAKER_AMP);\n    //if (pinAmp) {\n    //    bool on = SoundOutputDestination::Speaker == soundOutputDestination;\n    //    pinAmp->setDigitalValue(on ? 1 : 0);\n    //}\n}\n\n/**\n* Set a source of digital sound data (PCM) for making tones.\n* Samples are 1020 x 10bit unsigned PCM.\n* A reference to the buffer is kept to avoid the memory overhead, so changes to the buffer\n* values are reflected immediately to the sound output. \n*/\n//% help=music/set-tone\n//% weight=1 group=\"Tones\"\n//% deprecated\n//% blockId=music_set_tone block=\"set tone %buffer\"\nvoid setTone(Buffer buffer) {\n    if (!buffer) return;\n\n    if (buffer->length != TONE_WIDTH * sizeof(uint16_t))\n        return; // invalid length\n\n    decrRC(tone);\n    tone = buffer; // keep a reference to the buffer\n    incrRC(tone);\n\n    auto synth = &getWSynthesizer()->synth;\n    synth->setTone((const uint16_t*)tone->data);\n}\n\n/**\n* Turn the on-board speaker on or off.\n* @param out the destination for sounds generated by the synthesizer\n*/\n// weight=2\n// blockId=music_set_output block=\"set output %out\"\n// parts=\"speaker\" blockGap=8 advanced=true\nvoid setOutput(SoundOutputDestination out) {\n    if (out != soundOutputDestination) {\n        soundOutputDestination = out;\n        updateSpeakerAmp();\n    }    \n}\n\n/**\n* Set the output volume of the sound synthesizer.\n* @param volume the volume 0...256, eg: 128\n*/\n//% blockId=synth_set_volume block=\"set volume %volume\"\n//% parts=\"speaker\"\n//% volume.min=0 volume.max=256\n//% help=music/set-volume\n//% weight=70\nvoid setVolume(int volume) {\n    auto synth = &getWSynthesizer()->synth;\n    synth->setVolume(max(0, min(1024, volume * 4)));\n}\n\n/**\n* Play a tone through the speaker for some amount of time.\n* @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n* @param ms tone duration in milliseconds (ms), eg: music.beat(BeatFraction.Half)\n*/\n//% help=music/play-tone\n//% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n//% parts=\"headphone\" async\n//% blockNamespace=music\n//% weight=76 blockGap=8\nvoid playTone(int frequency, int ms) {\n    auto synth = &getWSynthesizer()->synth;\n    \n    if (frequency <= 0) {\n        synth->setFrequency(0, max(1, ms));\n    } else {\n        if (ms > 0) {\n            int d = max(1, ms - NOTE_PAUSE); // allow for short rest\n            int r = max(1, ms - d);\n            synth->setFrequency((float) frequency, d);\n            synth->setFrequency(0, r);\n        } else {\n            // ring\n            synth->setFrequency((float) frequency);                \n        }\n    }\n    fiber_sleep(1);\n}\n\n}",
      "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: 100\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
      "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#D83B01 weight=90 icon=\"\\uf025\"\nnamespace music {\n}",
      "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
      "pxt.json": "{\n  \"name\": \"music\",\n  \"description\": \"The music library\",\n  \"files\": [\n    \"README.md\",\n    \"music.cpp\",\n    \"enums.d.ts\",\n    \"shims.d.ts\",\n    \"melodies.ts\",\n    \"music.ts\",\n    \"piano.ts\",\n    \"ns.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace music {\n\n    /**\n     * Set a source of digital sound data (PCM) for making tones.\n     * Samples are 1020 x 10bit unsigned PCM.\n     * A reference to the buffer is kept to avoid the memory overhead, so changes to the buffer\n     * values are reflected immediately to the sound output. \n     */\n    //% help=music/set-tone\n    //% weight=1 group=\"Tones\"\n    //% deprecated\n    //% blockId=music_set_tone block=\"set tone %buffer\" shim=music::setTone\n    function setTone(buffer: Buffer): void;\n\n    /**\n     * Set the output volume of the sound synthesizer.\n     * @param volume the volume 0...256, eg: 128\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=256\n    //% help=music/set-volume\n    //% weight=70 shim=music::setVolume\n    function setVolume(volume: int32): void;\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: music.beat(BeatFraction.Half)\n     */\n    //% help=music/play-tone\n    //% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8 shim=music::playTone\n    function playTone(frequency: int32, ms: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
    },
    "microphone": {
      "README.md": "# microphone\n\nThe microphone library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare enum LoudnessCondition {\n    //% block=\"loud\"\n    Loud = 2,  // LEVEL_THRESHOLD_HIGH\n    //% block=\"quiet\"\n    Quiet = 1,  // LEVEL_THRESHOLD_LOW\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "microphone.cpp": "#include \"pxt.h\"\n#include \"dmac.h\"\n#include \"SAMD21DAC.h\"\n#include \"SAMD21PDM.h\"\n#include \"LevelDetector.h\"\n\nnamespace pxt {\n\nclass WMicrophone {\n  public:\n    SAMD21PDM microphone;\n    LevelDetector level;\n    WMicrophone()\n        : microphone(*LOOKUP_PIN(MIC_DATA), *LOOKUP_PIN(MIC_CLOCK), pxt::getWDMAC()->dmac, 10000)\n        , level(microphone.output, 115, 20, DEVICE_ID_MICROPHONE)\n    {\n        microphone.enable();\n    }\n};\nSINGLETON(WMicrophone);\n\n}\n\nnamespace input {\n/**\n* Registers an event that runs when a lound sound is detected\n*/\n//% help=input/on-loud-sound\n//% blockId=input_on_loud_sound block=\"on loud sound\"\n//% parts=\"microphone\"\n//% weight=88 blockGap=12\nvoid onLoudSound(Action handler) {\n    getWMicrophone(); // wake up service\n    registerWithDal(DEVICE_ID_MICROPHONE, LEVEL_THRESHOLD_HIGH, handler);\n}\n\n/**\n* Reads the loudness through the microphone from 0 (silent) to 255 (loud)\n*/\n//% help=input/sound-level\n//% blockId=device_get_sound_level block=\"sound level\"\n//% parts=\"microphone\"\n//% weight=34 blockGap=8\nint soundLevel() {\n    // min value measured: 9.0\n    const float silence = 8.0f;\n    // getValue returns a 12bit, eg 4096\n    const int value = max(silence, getWMicrophone()->level.getValue());\n    // scaling\n    const float scale = 255 / log(4096 / silence);\n    // compute dB like value by mapping logarithmic level to 0.255\n    return (int) (log(value / silence) * scale);\n}\n\n/**\n* Sets the minimum threshold for a loud sound\n*/\n//% help=input/set-loud-sound-threshold\n//% blockId=input_set_loud_sound_threshold block=\"set loud sound threshold %value\"\n//% parts=\"microphone\"\n//% value.min=1 value.max=100\n//% group=\"More\" weight=14 blockGap=8\nvoid setLoudSoundThreshold(int value) {\n    getWMicrophone()->level.setHighThreshold(value);\n}\n}",
      "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
      "pxt.json": "{\n  \"name\": \"microphone\",\n  \"description\": \"The microphone library\",\n  \"files\": [\n    \"README.md\",\n    \"microphone.cpp\",\n    \"ns.ts\",\n    \"enums.d.ts\",\n    \"shims.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Registers an event that runs when a lound sound is detected\n     */\n    //% help=input/on-loud-sound\n    //% blockId=input_on_loud_sound block=\"on loud sound\"\n    //% parts=\"microphone\"\n    //% weight=88 blockGap=12 shim=input::onLoudSound\n    function onLoudSound(handler: () => void): void;\n\n    /**\n     * Reads the loudness through the microphone from 0 (silent) to 255 (loud)\n     */\n    //% help=input/sound-level\n    //% blockId=device_get_sound_level block=\"sound level\"\n    //% parts=\"microphone\"\n    //% weight=34 blockGap=8 shim=input::soundLevel\n    function soundLevel(): int32;\n\n    /**\n     * Sets the minimum threshold for a loud sound\n     */\n    //% help=input/set-loud-sound-threshold\n    //% blockId=input_set_loud_sound_threshold block=\"set loud sound threshold %value\"\n    //% parts=\"microphone\"\n    //% value.min=1 value.max=100\n    //% group=\"More\" weight=14 blockGap=8 shim=input::setLoudSoundThreshold\n    function setLoudSoundThreshold(value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "loops.forever(() => {\n    let level = input.soundLevel()\n    serial.writeValue(\"sound\", level)\n})\ninput.onLoudSound(() => {\n    serial.writeLine(\"loud\")\n})\n"
    },
    "lightsensor": {
      "README.md": "# lightsensor\n\nThe lightsensor library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum LightCondition {\n    //% block=\"dark\"\n    Dark = 1,  // ANALOG_THRESHOLD_LOW\n    //% block=\"bright\"\n    Bright = 2,  // ANALOG_THRESHOLD_HIGH\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "lightsensor.cpp": "#include \"pxt.h\"\n#include \"AnalogSensor.h\"\n\n\nenum class LightCondition {\n    //% block=\"dark\"\n    Dark = ANALOG_THRESHOLD_LOW,\n    //% block=\"bright\"\n    Bright = ANALOG_THRESHOLD_HIGH\n};\n\nnamespace pxt {\n\nclass WLight {\n  public:\n    AnalogSensor sensor;\n    WLight()\n        : sensor(*LOOKUP_PIN(LIGHT), DEVICE_ID_LIGHT_SENSOR) //\n    {\n        sensor.init();\n        sensor.setPeriod(50);\n        sensor.setSensitivity(868); // codal has 912 now\n        sensor.setLowThreshold(128);\n        sensor.setHighThreshold(896);\n    }\n};\nSINGLETON(WLight);\n\n}\n\nnamespace input {\n\n/**\n* Register an event that runs when light conditions (darker or brighter) change.\n* @param condition the condition that event triggers on\n*/\n//% help=input/on-light-condition-changed\n//% blockId=input_on_light_condition_changed block=\"on light %condition\"\n//% parts=\"lightsensor\"\n//% weight=84 blockGap=12\nvoid onLightConditionChanged(LightCondition condition, Action handler) {\n    auto sensor = &getWLight()->sensor;\n    sensor->updateSample();\n    registerWithDal(sensor->id, (int)condition, handler);\n}\n\n/**\n * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n */\n//% help=input/light-level\n//% blockId=device_get_light_level block=\"light level\"\n//% parts=\"lightsensor\"\n//% weight=30 blockGap=8\nint lightLevel() {\n    // 0...1023\n    int value = getWLight()->sensor.getValue();\n    return value / 4;\n}\n\n/**\n* Set the threshold value for the light condition event.\n*/\n//% help=input/set-light-threshold\n//% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n//% parts=\"lightsensor\"\n//% value.min=1 value.max=255\n//% group=\"More\" weight=13 blockGap=8\nvoid setLightThreshold(LightCondition condition, int value) {\n    int v = value * 4;\n    if (condition == LightCondition::Dark)\n        getWLight()->sensor.setLowThreshold(v);\n    else\n        getWLight()->sensor.setHighThreshold(v);\n}\n}\n",
      "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
      "pxt.json": "{\n  \"name\": \"lightsensor\",\n  \"description\": \"The lightsensor library\",\n  \"files\": [\n    \"README.md\",\n    \"lightsensor.cpp\",\n    \"ns.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Register an event that runs when light conditions (darker or brighter) change.\n     * @param condition the condition that event triggers on\n     */\n    //% help=input/on-light-condition-changed\n    //% blockId=input_on_light_condition_changed block=\"on light %condition\"\n    //% parts=\"lightsensor\"\n    //% weight=84 blockGap=12 shim=input::onLightConditionChanged\n    function onLightConditionChanged(condition: LightCondition, handler: () => void): void;\n\n    /**\n     * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n     */\n    //% help=input/light-level\n    //% blockId=device_get_light_level block=\"light level\"\n    //% parts=\"lightsensor\"\n    //% weight=30 blockGap=8 shim=input::lightLevel\n    function lightLevel(): int32;\n\n    /**\n     * Set the threshold value for the light condition event.\n     */\n    //% help=input/set-light-threshold\n    //% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n    //% parts=\"lightsensor\"\n    //% value.min=1 value.max=255\n    //% group=\"More\" weight=13 blockGap=8 shim=input::setLightThreshold\n    function setLightThreshold(condition: LightCondition, value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "loops.forever(() => {\n    serial.writeLine(`light=${input.lightLevel()}`);\n})"
    },
    "thermometer": {
      "README.md": "# temperature\n\nThe temperature library.\n\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum TemperatureCondition {\n    //% block=\"hot\"\n    Hot = 2,  // ANALOG_THRESHOLD_HIGH\n    //% block=\"cold\"\n    Cold = 1,  // ANALOG_THRESHOLD_LOW\n    }\n\n\n    declare const enum TemperatureUnit {\n    //% block=\"C\"\n    Celsius = 0,\n    //% block=\"F\"\n    Fahrenheit = 1,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
      "pxt.json": "{\n  \"name\": \"thermometer\",\n  \"description\": \"A thermometer cdriver\",\n  \"files\": [\n    \"README.md\",\n    \"temperature.cpp\",\n    \"shims.d.ts\",\n    \"enums.d.ts\",\n    \"ns.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Run some code when the temperature changes from hot to cold, or from cold to hot.\n     * @param condition the condition, hot or cold, the event triggers on\n     * @param temperature the temperature at which this event happens, eg: 15\n     * @param unit the unit of the temperature\n     */\n    //% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n    //% parts=\"thermometer\"\n    //% help=input/on-temperature-condition-changed blockExternalInputs=0\n    //% group=\"More\" weight=76 shim=input::onTemperatureConditionChanged\n    function onTemperatureConditionChanged(condition: TemperatureCondition, temperature: int32, unit: TemperatureUnit, handler: () => void): void;\n\n    /**\n     * Get the temperature in Celsius or Fahrenheit degrees.\n     */\n    //% help=input/temperature\n    //% blockId=device_temperature block=\"temperature in %unit\"\n    //% parts=\"thermometer\"\n    //% weight=26 shim=input::temperature\n    function temperature(unit: TemperatureUnit): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "temperature.cpp": "#include \"pxt.h\"\n#include \"AnalogSensor.h\"\n#include \"NonLinearAnalogSensor.h\"\n#include \"Button.h\"\n\nenum class TemperatureCondition {\n    //% block=\"hot\"\n    Hot = ANALOG_THRESHOLD_HIGH,\n    //% block=\"cold\"\n    Cold = ANALOG_THRESHOLD_LOW\n};\n\nenum class TemperatureUnit {\n    //% block=\"C\"\n    Celsius,\n    //% block=\"F\"\n    Fahrenheit\n};\n\nnamespace pxt {\n\n// Wrapper classes\nclass WTemp {\n  public:\n    NonLinearAnalogSensor sensor;\n    WTemp()\n        : sensor(*LOOKUP_PIN(TEMPERATURE), DEVICE_ID_THERMOMETER, 25, 10000, 3380, 10000,\n                 273.5) //\n    {\n        sensor.init();\n    }\n};\nSINGLETON(WTemp);\n\n}\n\nnamespace input {\n\n/**\n* Run some code when the temperature changes from hot to cold, or from cold to hot.\n* @param condition the condition, hot or cold, the event triggers on\n* @param temperature the temperature at which this event happens, eg: 15\n* @param unit the unit of the temperature\n*/\n//% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n//% parts=\"thermometer\"\n//% help=input/on-temperature-condition-changed blockExternalInputs=0\n//% group=\"More\" weight=76\nvoid onTemperatureConditionChanged(TemperatureCondition condition, int temperature, TemperatureUnit unit, Action handler) {\n    auto sensor = &getWTemp()->sensor;\n    sensor->updateSample();\n\n    int t = unit == TemperatureUnit::Celsius ? temperature : ((temperature - 32) * 10) / 18;\n\n    if (condition == TemperatureCondition::Cold)\n        sensor->setLowThreshold(t);\n    else\n        sensor->setHighThreshold(t);\n    registerWithDal(sensor->id, (int)condition, handler);\n}\n\n/**\n * Get the temperature in Celsius or Fahrenheit degrees.\n */\n//% help=input/temperature\n//% blockId=device_temperature block=\"temperature in %unit\"\n//% parts=\"thermometer\"\n//% weight=26\nint temperature(TemperatureUnit unit) {\n    int value = getWTemp()->sensor.getValue();\n    if (unit == TemperatureUnit::Celsius) return value;\n    else return (value * 18) / 10 + 32;\n}\n}\n",
      "test.ts": ""
    },
    "touch": {
      "README.md": "# touch\n\nThe capacitive touch library.\n\n",
      "enums.d.ts": "\n",
      "pxt.json": "{\n  \"name\": \"touch\",\n  \"description\": \"The capacitive touch library\",\n  \"files\": [\n    \"README.md\",\n    \"touch.h\",\n    \"touch.cpp\",\n    \"touch.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\",\n    \"buttons\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface TouchButton {\n    /**\n     * Manually define the threshold use to detect a touch event. Any sensed value equal to or greater than this value will be interpreted as a touch.\n     * @param name button name\n     * @param threshold minimum value to consider a touch eg:200\n     */\n    //% blockId=touch_set_threshold block=\"button %button|set threshold %threshold\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% group=\"More\" weight=16 blockGap=8\n    //% help=input/touch/set-threshold shim=TouchButtonMethods::setThreshold\n    setThreshold(threshold: int32): void;\n\n    /**\n     * Reads the current value registered with the button.\n     * @param name button name\n     */\n    //% blockId=touch_value block=\"button %button|value\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% group=\"More\" weight=49 blockGap=8\n    //% help=input/touch/value shim=TouchButtonMethods::value\n    value(): int32;\n}\n\n\ndeclare interface AnalogPin {\n    /**\n     * Get the cap-touch sensor for given pin (if available)\n     */\n    //% shim=AnalogPinMethods::touchButton\n    touchButton(): TouchButton;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": "",
      "touch.cpp": "#include \"pxt.h\"\n#include \"touch.h\"\n\nnamespace pxt {\n//%\nTouchButton getTouchButton(int id) {\n    auto cpid = DEVICE_ID_FIRST_TOUCHBUTTON + id;\n    auto btn = (CapTouchButton*)lookupComponent(cpid);\n    if (btn == NULL) {\n        // 'new' will add it to component list\n        btn = new CapTouchButton(*pxt::getPin(id));\n        btn->id = cpid;\n    }\n    return btn;\n}\n}\n\n\nnamespace TouchButtonMethods {\n\n/**\n * Manually define the threshold use to detect a touch event. Any sensed value equal to or greater than this value will be interpreted as a touch.\n * @param name button name\n * @param threshold minimum value to consider a touch eg:200\n */\n//% blockId=touch_set_threshold block=\"button %button|set threshold %threshold\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% group=\"More\" weight=16 blockGap=8\n//% help=input/touch/set-threshold\nvoid setThreshold(TouchButton button, int threshold) {\n    button->setThreshold(max(0, min(1023, threshold)));\n}\n\n/**\n * Reads the current value registered with the button.\n * @param name button name\n */\n//% blockId=touch_value block=\"button %button|value\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% group=\"More\" weight=49 blockGap=8\n//% help=input/touch/value\nint value(TouchButton button) {\n    return button->getValue();\n}\n\n}\n\nnamespace AnalogPinMethods {\n    \n/**\n * Get the cap-touch sensor for given pin (if available)\n */\n//%\nTouchButton touchButton(AnalogPin pin) {\n    if (PA02 <= pin->name && pin->name <= PA07)\n        ;\n    else if (PB02 <= pin->name && pin->name <= PB09)\n        ;\n    else\n        return NULL;\n    return pxt::getTouchButton(pin->name);\n}\n\n}\n",
      "touch.h": "#define TouchButton CapTouchButton *\n",
      "touch.ts": "//% noRefCounting fixedInstances\ninterface TouchButton extends Button {\n    // methods filled from C++\n}\n"
    },
    "switch": {
      "README.md": "# switch\n\nThe build-in slide switch library.\n",
      "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SwitchDirection {\n    //% block=\"left\"\n    Left = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"right\"\n    Right = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
      "ns.ts": "//% color=\"#d65cd6\"\nnamespace input {\n}\n",
      "pxt.json": "{\n  \"name\": \"switch\",\n  \"description\": \"A slide switch\",\n  \"files\": [\n    \"README.md\",\n    \"switch.cpp\",\n    \"ns.ts\",\n    \"shims.d.ts\",\n    \"enums.d.ts\"\n  ],\n  \"dependencies\": {\n    \"core\": \"*\"\n  },\n  \"public\": true\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Do something when the slide switch is moved left or right.\n     *\n     * @param direction the direction the switch must be moved to trigget the event\n     */\n    //% help=input/on-switch-moved\n    //% blockId=device_on_switch_moved block=\"on switch moved %direction\"\n    //% parts=\"switch\"\n    //% weight=80 shim=input::onSwitchMoved\n    function onSwitchMoved(direction: SwitchDirection, handler: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "switch.cpp": "#include \"pxt.h\"\n#include \"Button.h\"\n#include \"pins.h\"\n\nenum class SwitchDirection {\n    //% block=\"left\"\n    Left = DEVICE_BUTTON_EVT_UP,\n    //% block=\"right\"\n    Right = DEVICE_BUTTON_EVT_DOWN\n};\n\nnamespace pxt {\n\n// Wrapper classes\nclass WSwitch {\n  public:\n    Button slideSwitch;\n\n    WSwitch()\n        : slideSwitch(*LOOKUP_PIN(BTN_SLIDE), DEVICE_ID_BUTTON_SLIDE,\n                      DEVICE_BUTTON_SIMPLE_EVENTS, ACTIVE_LOW, PullMode::Up) {}\n};\nSINGLETON(WSwitch);\n\n}\n\nnamespace input {\n/**\n* Do something when the slide switch is moved left or right.\n*\n* @param direction the direction the switch must be moved to trigget the event\n*/\n//% help=input/on-switch-moved\n//% blockId=device_on_switch_moved block=\"on switch moved %direction\"\n//% parts=\"switch\"\n//% weight=80\nvoid onSwitchMoved(SwitchDirection direction, Action handler) {\n    registerWithDal(getWSwitch()->slideSwitch.id, (int)direction, handler);\n}\n\n/*\n* Gets a value indicating if the switch is positioned to the right\n*/\n//% blockId=device_switch_direction block=\"switch right\"\n//% parts=\"switch\"\n//% group=\"Switch\" weight=10 blockGap=8\nbool switchRight() {\n    auto slide = getWSwitch();\n    return slide->slideSwitch.isPressed();\n}\n\n}"
    },
    "pulse": {
      "README.md": "# pulse\n\nThe Pulse library.\n\n",
      "bitvector.h": "#ifndef CABLE_BITVECTOR_H\n#define CABLE_BITVECTOR_H\n\nclass BitVector {\n    Segment data;\n    int len;\n\n    uint32_t get32(int idx) { return (uint32_t)data.get(idx >> 5); }\n\n  public:\n    BitVector() { len = 0; }\n    ~BitVector() { data.destroy(); }\n\n    int size() { return len; }\n\n    void print() {\n        char buf[size() + 1];\n        for (int i = 0; i < size(); ++i)\n            buf[i] = get(i) ? '#' : '.';\n        buf[size()] = 0;\n        DMESG(\"bits: %s\", buf);\n    }\n\n    int get(int pos) {\n        if (pos < 0 || pos >= len)\n            return 0;\n        return !!(get32(pos) & (1 << (pos & 31)));\n    }\n    uint32_t getBits(int pos, int num) {\n        uint32_t res = get32(pos);\n        int off = pos & 31;\n        res >>= off;\n        off = 32 - off;\n        if (num > off) {\n            res |= get32(pos + 32) << off;\n        }\n        if (num < 32)\n            res &= (1U << num) - 1;\n        return res;\n    }\n    void set(int pos, int v) {\n        if (pos < 0 || pos >= len)\n            return;\n        auto curr = get32(pos);\n        auto mask = 1 << (pos & 31);\n        if (v)\n            curr |= mask;\n        else\n            curr &= ~mask;\n        data.set(pos >> 5, (TValue)curr);\n    }\n    void setLength(uint32_t newLength) {\n        len = newLength;\n        data.setLength((len + 31) >> 5);\n    }\n    void push(int v) {\n        setLength(len + 1);\n        set(len - 1, v);\n    }\n};\n\n#endif",
      "ns.ts": "/**\n * Communication between devices\n */\n//% color=#E3008C weight=89 icon=\"\\uf086\"\n//% groups='[\"Infrared\", \"Cable\"]'\nnamespace network {\n}",
      "pulse.cpp": "#include \"pxt.h\"\n#include \"pulse.h\"\n\n// from samd21.cpp\nvoid NVIC_Setup();\nvoid setPeriodicCallback(uint32_t usec, void *data, void (*callback)(void *));\nvoid clearPeriodicCallback();\nvoid setTCC0(int enabled);\n\nnamespace network {\n\nstatic const uint8_t hamming[16] = {\n    0b0000000, 0b1110000, 0b1001100, 0b0111100, 0b0101010, 0b1011010, 0b1100110, 0b0010110,\n    0b1101001, 0b0011001, 0b0100101, 0b1010101, 0b1000011, 0b0110011, 0b0001111, 0b1111111,\n};\n\nstatic const uint8_t invHamming[64] = {\n    0x00, 0x0c, 0x0a, 0x7e, 0x09, 0x4e, 0x2e, 0xee, 0x09, 0x7d, 0x7b, 0x77, 0x99, 0x59, 0x39, 0x7e,\n    0x0a, 0x4d, 0xaa, 0x6a, 0x48, 0x44, 0x3a, 0x4e, 0x1d, 0xdd, 0x3a, 0x7d, 0x39, 0x4d, 0x33, 0x3f,\n    0x0c, 0xcc, 0x2b, 0x6c, 0x28, 0x5c, 0x22, 0x2e, 0x1b, 0x5c, 0xbb, 0x7b, 0x59, 0x55, 0x2b, 0x5f,\n    0x18, 0x6c, 0x6a, 0x66, 0x88, 0x48, 0x28, 0x6f, 0x11, 0x1d, 0x1b, 0x6f, 0x18, 0x5f, 0x3f, 0xff};\n\nstatic const uint8_t bitsToGap[4] = {1, 2, 4, 3};\nstatic const uint8_t gapToBits[5] = {0b00, 0b00, 0b01, 0b11, 0b10};\n\nstatic int lookupInvHaming(int v) {\n    int k = invHamming[v >> 1];\n    if (v & 1)\n        return (k & 0xf);\n    else\n        return (k >> 4);\n}\n\nstatic void decodeHamming(uint32_t r, uint8_t *dst) {\n    int a0 = 0;\n    int a1 = 0;\n    int b0 = 0;\n    int b1 = 0;\n    int p = 0;\n\n    for (int i = 0; i < 7; ++i) {\n        a0 |= ((r >> p++) & 1) << i;\n        b0 |= ((r >> p++) & 1) << i;\n        a1 |= ((r >> p++) & 1) << i;\n        b1 |= ((r >> p++) & 1) << i;\n    }\n\n    dst[0] = (lookupInvHaming(a0) << 4) | lookupInvHaming(a1);\n    dst[1] = (lookupInvHaming(b0) << 4) | lookupInvHaming(b1);\n}\n\nstatic void pushTwo(BitVector &bv, uint8_t a, uint8_t b) {\n    int gap = bitsToGap[b * 2 + a];\n    bv.push(1);\n    while (gap--)\n        bv.push(0);\n}\n\nstatic void encodeHamming(BitVector &bv, uint8_t a, uint8_t b) {\n    int a0 = hamming[a >> 4];\n    int a1 = hamming[a & 0xf];\n    int b0 = hamming[b >> 4];\n    int b1 = hamming[b & 0xf];\n    for (int i = 0; i < 7; ++i) {\n        pushTwo(bv, (a0 >> i) & 1, (b0 >> i) & 1);\n        pushTwo(bv, (a1 >> i) & 1, (b1 >> i) & 1);\n    }\n}\n\nuint16_t crc16ccit(uint8_t *data, uint32_t len) {\n    uint16_t crc = 0xffff;\n\n    while (len--) {\n        crc ^= (*data++ << 8);\n        for (int i = 0; i < 8; ++i) {\n            if (crc & 0x8000)\n                crc = crc << 1 ^ 0x1021;\n            else\n                crc = crc << 1;\n        }\n    }\n\n    return crc;\n}\n\nPulseBase::PulseBase(uint16_t id, int pinOut, int pinIn) {\n    NVIC_Setup();\n    this->id = id;\n\n    recvState = PULSE_RECV_ERROR;\n    sending = false;\n    outBuffer = NULL;\n    pin = lookupPin(pinOut);\n    if (pin) {\n        pin->setDigitalValue(0);\n\n        inpin = lookupPin(pinIn);\n\n        devMessageBus.listen(id, PULSE_PACKET_END_EVENT, this, &PulseBase::packetEnd);\n    }\n}\n\nvoid PulseBase::setupGapEvents() {\n    devMessageBus.listen(inpin->id, DEVICE_PIN_EVT_PULSE_HI, this, &PulseBase::pulseGap,\n                         MESSAGE_BUS_LISTENER_IMMEDIATE);\n    devMessageBus.listen(inpin->id, DEVICE_PIN_EVT_PULSE_LO, this, &PulseBase::pulseMark,\n                         MESSAGE_BUS_LISTENER_IMMEDIATE);\n    listen();\n}\n\nvoid PulseBase::listen() {\n    inpin->getDigitalValue();\n    inpin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n}\n\nvoid PulseBase::setupPWM() {\n    pin->setAnalogPeriodUs(1000 / 38); // 38kHz\n    pin->setAnalogValue(333);\n    setPWM(1);\n}\n\nvoid PulseBase::setPWM(int enabled) {\n    // pin->setPwm(enabled);\n    setTCC0(enabled);\n    pwmstate = enabled;\n}\n\nvoid PulseBase::finishPWM() {\n    pin->setAnalogValue(0);\n    setPWM(1);\n}\n\nvoid PulseBase::send(Buffer d) {\n    if (sending)\n        return; // error code?\n\n    if (d->length > PULSE_MAX_MSG_SIZE - 2 || (d->length & 1))\n        return; // error code?\n\n    encodedMsg.setLength(0);\n    for (int i = 0; i < 25; ++i)\n        encodedMsg.push(1);\n\n    for (int i = 0; i < 8; ++i)\n        encodedMsg.push(0);\n\n    for (int i = 0; i < d->length; i += 2) {\n        encodeHamming(encodedMsg, d->data[i], d->data[i + 1]);\n    }\n\n    uint16_t crc = crc16ccit(d->data, d->length);\n    encodeHamming(encodedMsg, crc & 0xff, crc >> 8);\n\n    for (int i = 0; i < 15; ++i)\n        encodedMsg.push(1);\n\n    auto gap = system_timer_current_time_us() - lastSendTime;\n    // we require 200ms between sends\n    if (gap < 200000) {\n        gap = (200000 - gap) / 1000;\n        fiber_sleep(gap);\n    }\n\n    while (isReciving())\n        fiber_sleep(10);\n    lastSendTime = system_timer_current_time_us();\n\n    // encodedMsg.print();\n\n    sending = true;\n    sendStartTime = 0;\n    setupPWM();\n\n    sendPtr = 0;\n\n    setPeriodicCallback(PULSE_PULSE_LEN, this, (void (*)(void *)) & PulseBase::process);\n    while (sending) {\n        fiber_sleep(10);\n    }\n    fiber_sleep(5);\n}\n\nvoid PulseBase::finish(int code) {\n    if (recvState == PULSE_RECV_ERROR)\n        return;\n\n    if (code == 0) {\n        Event evt(id, PULSE_PACKET_END_EVENT);\n    } else {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"IR ERROR %d [%s]\", code, dbg.get());\n    }\n    dbg.get();\n    recvState = PULSE_RECV_ERROR;\n}\n\nvoid PulseBase::addPulse(int v) {\n    if (this->pulsePtr < PULSE_MAX_PULSES - 1) {\n        pulses[this->pulsePtr++] = (int16_t)v;\n    } else {\n        finish(2);\n    }\n}\n\nint PulseBase::adjustShift() {\n    int pulseLen = (pulses[0] - pulses[1]) / 9;\n    PULSE_DMESG(\"prev: %d %d %d %d %d %d %d %d %d %d\", pulses[0], pulses[1], pulses[2], pulses[3],\n                pulses[4], pulses[5], pulses[6], pulses[7], pulses[8], pulses[9], pulses[10],\n                pulses[11]);\n    return pulseLen;\n}\n\nvoid PulseBase::pulseGap(Event ev) {\n    if (sending)\n        return;\n\n    if (ev.timestamp > 10000) {\n        dbg.put(\" BRK \");\n        finish(11);\n        return;\n    }\n\n    int tm = (int)ev.timestamp;\n\n    dbg.putNum(tm);\n\n    if (recvState == PULSE_WAIT_START_GAP) {\n        pulsePtr = 0;\n        startTime = system_timer_current_time_us() - tm;\n        addPulse(tm);\n        recvState = PULSE_WAIT_DATA;\n        dbg.put(\" *** \");\n        return;\n    }\n\n    if (recvState == PULSE_WAIT_DATA) {\n        addPulse(tm);\n        return;\n    }\n}\n\nvoid PulseBase::packetEnd(Event) {\n    if (pulsePtr < 5)\n        return;\n\n    int pulseLen = adjustShift();\n    int numBits = 0;\n    uint32_t r = 0;\n    uint8_t buf[PULSE_MAX_MSG_SIZE];\n    int ptr = 0;\n\n    for (int i = 2; i < pulsePtr; ++i) {\n        if (pulses[i] > 0) {\n            int len = (pulses[i] + pulseLen / 2) / pulseLen;\n            if (len > 4)\n                len = 4;\n            r |= (uint32_t)gapToBits[len] << numBits;\n            numBits += 2;\n            if (numBits == 28) {\n                decodeHamming(r, buf + ptr);\n                numBits = 0;\n                r = 0;\n                ptr += 2;\n            }\n        }\n    }\n\n    pulsePtr = 0;\n\n    if (numBits != 0) {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"left over bits: %d\", numBits);\n        return;\n    }\n\n    if (ptr < 4) {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"too short: %d\", ptr);\n        return; // too short\n    }\n\n    ptr -= 2;\n    uint16_t crc = crc16ccit(buf, ptr);\n    uint16_t pktCrc = (buf[ptr + 1] << 8) | buf[ptr];\n\n    decrRC(outBuffer);\n    outBuffer = pins::createBuffer(ptr);\n    memcpy(outBuffer->data, buf, ptr);\n    if (crc != pktCrc)\n        PULSE_DMESG(\"crc fail: %x %x len=%d\", crc, pktCrc, pulseLen);\n    Event evt(id, crc == pktCrc ? PULSE_PACKET_EVENT : PULSE_PACKET_ERROR_EVENT);\n}\n\nvoid PulseBase::pulseMark(Event ev) {\n    if (sending)\n        return;\n\n    if (ev.timestamp > 10000) {\n        dbg.put(\" -BRK \");\n        finish(10);\n        return;\n    }\n\n    int tm = (int)ev.timestamp;\n\n    dbg.putNum(-tm);\n\n    lastMarkTime = system_timer_current_time_us();\n\n    if (tm >= 20 * PULSE_PULSE_LEN) {\n        recvState = PULSE_WAIT_START_GAP;\n        return;\n    }\n\n    if (recvState == PULSE_WAIT_DATA) {\n        if (tm >= 12 * PULSE_PULSE_LEN) {\n            // finish\n            addPulse(-(40 * PULSE_PULSE_LEN)); // make sure we get all ones at the end\n            finish(0);\n        } else {\n            addPulse(-tm);\n        }\n    }\n}\n\nbool PulseBase::isReciving() {\n    auto now = system_timer_current_time_us();\n    // inpin low means mark\n    if (inpin->getDigitalValue() == 0 || now - lastMarkTime < 10000) {\n        return true;\n    }\n    return false;\n}\n\nBuffer PulseBase::getBuffer() {\n    incrRC(outBuffer);\n    return outBuffer;\n}\n\nvoid PulseBase::process() {\n    if (!sending)\n        return;\n\n    auto now = system_timer_current_time_us();\n    if (sendStartTime == 0)\n        sendStartTime = now - (PULSE_PULSE_LEN / 2);\n\n    auto encodedMsgPtr = (int)(now - sendStartTime) / PULSE_PULSE_LEN;\n\n    encodedMsgPtr = sendPtr++;\n\n    if (encodedMsgPtr >= encodedMsg.size()) {\n        encodedMsg.setLength(0);\n        finishPWM();\n        clearPeriodicCallback();\n        sending = false;\n        return;\n    }\n\n    int curr = encodedMsg.get(encodedMsgPtr);\n    if (curr != pwmstate)\n        setPWM(curr);\n}\n}\n",
      "pulse.h": "#ifndef CABLE_PULSE_H\n#define CABLE_PULSE_H\n\n#include \"pxt.h\"\n#include \"bitvector.h\"\n\n#define PULSE_MAX_MSG_SIZE 34\n#define PULSE_PACKET_END_EVENT 0x1\n#define PULSE_PACKET_EVENT 0x2\n#define PULSE_PACKET_ERROR_EVENT 0x3\n#define PULSE_MAX_PULSES (PULSE_MAX_MSG_SIZE * 14 + 10)\n#define PULSE_PULSE_LEN 250\n\n#define PULSE_IR_COMPONENT_ID 0x2042\n#define PULSE_CABLE_COMPONENT_ID 0x2043\n\n#define PULSE_DEBUG 0\n\n#if PULSE_DEBUG\n#define PULSE_DMESG DMESG\n#else\n#define PULSE_DMESG(...)                                                                           \\\n    do {                                                                                           \\\n    } while (0)\n#endif\n\nnamespace network {\n\nclass DbgBuffer {\n  public:\n#if PULSE_DEBUG\n    char dbgBuf[1200];\n    int dbgPtr;\n    DbgBuffer() {\n        dbgBuf[0] = 0;\n        dbgPtr = 0;\n    }\n#endif\n\n    void put(const char *msg) {\n#if IR_DEBUG\n        int len = strlen(msg);\n        if (len + dbgPtr > (int)sizeof(dbgBuf) - 1) {\n            dbgPtr = 1;\n            dbgBuf[0] = '>';\n        }\n        memcpy(dbgBuf + dbgPtr, msg, len + 1);\n        dbgPtr += len;\n#endif\n    }\n\n    void putNum(int n) {\n#if IR_DEBUG\n        char buf[30];\n        itoa(n, buf);\n        put(\" \");\n        put(buf);\n#endif\n    }\n\n    const char *get() {\n#if IR_DEBUG\n        dbgPtr = 0;\n        return dbgBuf;\n#else\n        return \"NoDebug\";\n#endif\n    }\n};\n\nenum PulseRecvState : uint8_t {\n    PULSE_RECV_ERROR,\n    PULSE_WAIT_START_GAP,\n    PULSE_WAIT_DATA,\n};\n\nclass PulseBase {\n  protected:\n    DevicePin *pin;\n    DevicePin *inpin;\n    BitVector encodedMsg;\n    uint16_t sendPtr;\n    int8_t pwmstate;\n    bool sending;\n    uint16_t id;\n    uint64_t startTime;\n    uint64_t sendStartTime;\n    uint64_t lastMarkTime;\n    uint64_t lastSendTime;\n\n    int16_t pulses[PULSE_MAX_PULSES + 1];\n    uint16_t pulsePtr;\n\n    PulseRecvState recvState;\n    Buffer outBuffer;\n\n    DbgBuffer dbg;\n\n  public:\n    PulseBase(uint16_t id, int pinOut, int pinIn);\n    virtual void setupGapEvents();\n    virtual void listen();\n    virtual void setupPWM();\n    virtual void setPWM(int enabled);\n    virtual void finishPWM();\n    void send(Buffer d);\n    void finish(int code);\n    void addPulse(int v);\n    int adjustShift();\n    void pulseGap(Event ev);\n    int errorRate(int start, BitVector &bits);\n    void packetEnd(Event);\n    void pulseMark(Event ev);\n    Buffer getBuffer();\n    bool isReciving();\n    void process();\n};\n}\n#endif",
      "pxt.json": "{\n  \"name\": \"pulse\",\n  \"description\": \"Communication over pulses\",\n  \"files\": [\n    \"README.md\",\n    \"pulse.cpp\",\n    \"pulse.h\",\n    \"bitvector.h\",\n    \"samd21.cpp\",\n    \"shims.d.ts\",\n    \"ns.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "samd21.cpp": "#include \"pxt.h\"\n\n\nstatic void NVIC_CopyToRAM() {\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n    // Copy and switch to dynamic vectors if the first time called\n    if (SCB->VTOR <= 0x1000000) {\n        uint32_t *old_vectors = vectors;\n        uint32_t tmp = (uint32_t)malloc(NVIC_NUM_VECTORS * 4 + 256);\n        while (tmp & 0xff)\n            tmp++;\n        vectors = (uint32_t *)tmp;\n        for (int i = 0; i < NVIC_NUM_VECTORS; i++) {\n            vectors[i] = old_vectors[i];\n        }\n        SCB->VTOR = (uint32_t)vectors;\n    }\n}\n\nvoid NVIC_Setup() {\n    NVIC_SetPriority(EIC_IRQn, 0);\n    NVIC_SetPriority(TC4_IRQn, 1);\n    DMESG(\"set interrupt priority, TC4=%d EIC=%d\", NVIC_GetPriority(TC4_IRQn),\n          NVIC_GetPriority(EIC_IRQn));\n}\n\nstatic volatile bool periodicUsed;\nstatic void *periodicData;\nstatic void (*periodicCallback)(void *);\nstatic void periodicIRQ() {\n    TC3->COUNT16.INTFLAG.reg = TC_INTFLAG_MC(1);\n    periodicCallback(periodicData);\n}\n\nvoid setPeriodicCallback(uint32_t usec, void *data, void (*callback)(void *)) {\n    while (periodicUsed) {\n        fiber_sleep(5);\n    }\n\n    if (usec > 8000)\n        target_panic(42);\n\n    periodicUsed = true;\n    periodicData = data;\n    periodicCallback = callback;\n\n    NVIC_CopyToRAM();\n    NVIC_DisableIRQ(TC3_IRQn);\n    NVIC_SetPriority(TC3_IRQn, 1);\n\n    struct tc_module ticker_module;\n    struct tc_config config_tc;\n\n    tc_get_config_defaults(&config_tc);\n    config_tc.run_in_standby = true;\n    config_tc.wave_generation = TC_WAVE_GENERATION_MATCH_FREQ;\n\n    tc_init(&ticker_module, TC3, &config_tc);\n    tc_enable(&ticker_module);\n    tc_set_compare_value(&ticker_module, TC_COMPARE_CAPTURE_CHANNEL_0, 8 * usec - 1);\n\n    TC3->COUNT16.COUNT.reg = 0;\n    TC3->COUNT16.INTENSET.reg = TC_INTENSET_MC0;\n\n    NVIC_SetVector(TC3_IRQn, (uint32_t)periodicIRQ);\n    NVIC_EnableIRQ(TC3_IRQn);\n}\n\nvoid clearPeriodicCallback() {\n    if (!periodicUsed) {\n        target_panic(42);\n    }\n\n    NVIC_DisableIRQ(TC3_IRQn);\n    TC3->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;\n    NVIC_SetVector(TC3_IRQn, (uint32_t)TC3_Handler);\n    periodicUsed = false;\n}\n\nvoid setTCC0(int enabled) {\n    while (TCC0->STATUS.reg & TC_STATUS_SYNCBUSY)\n        ;\n    if (enabled)\n        TCC0->CTRLA.reg |= TC_CTRLA_ENABLE;\n    else\n        TCC0->CTRLA.reg &= ~TC_CTRLA_ENABLE;\n}\n",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace network {\n\n    /**\n     * Send data over cable.\n     */\n    //% parts=\"cable\" shim=network::cableSendPacket\n    function cableSendPacket(buf: Buffer): void;\n\n    /**\n     * Get most recent packet received over cable.\n     */\n    //% parts=\"cable\" shim=network::cablePacket\n    function cablePacket(): Buffer;\n\n    /**\n     * Run action after a packet is recieved over cable.\n     */\n    //% parts=\"cable\" shim=network::onCablePacket\n    function onCablePacket(body: () => void): void;\n\n    /**\n     * Run action after there's an error reciving packet over cable.\n     */\n    //% shim=network::onCableError\n    function onCableError(body: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
    },
    "lightbulb": {
      "README.md": "",
      "lightbulb.cpp": "namespace lightbulb {\n\n    /**\n     * Set the rgb led to a specific red, green, blue color.\n     * @param red the red color\n     * @param green the green color\n     * @param blue the blue color\n     */\n     //% parts=\"rgbled\"\n    void setRGBLed(int r, int g, int b) {\n    }\n}",
      "lightbulb.ts": "\n/**\n * Outputs.\n */\n//% groups='[\"other\", \"Colors\"]'\n//% color=\"#0078d7\" weight=97 icon=\"\\uf0eb\"\nnamespace lightbulb {\n\n    let _brightness: number;\n\n    /**\n     * Make the on-board RGB LED show an RGB color (range 0-255 for r, g, b).\n     * @param rgb RGB color of the LED, eg: Colors.Red\n     */\n    //% blockId=\"rgb_set_color\" block=\"set light bulb to %rgb=colorNumberPicker\"\n    //% weight=90 help=\"rgb/set-color\"\n    export function setColor(rgb: number) {\n        if (_brightness == undefined) {\n            _brightness = 20;\n        }\n\n        rgb = fade(rgb, _brightness);\n        let red = unpackR(rgb);\n        let green = unpackG(rgb);\n        let blue = unpackB(rgb);\n\n        setRGBLed(red, green, blue);\n    }\n    /**\n     * Clear the on-board RGB LED, turning it off.\n     */\n    //% blockId=\"rgb_clear\" block=\"clear light bulb\"\n    //% weight=89 help=\"rgb/clear\"\n    export function clear() {\n        setRGBLed(0, 0, 0);\n    }\n\n    /**\n     * Set the brightness of the LED. This change the brightness for the next operation.\n     * @param brightness a measure of LED brightness in 0-100. eg: 15\n     */\n    //% blockId=\"rgb_set_brightness\" block=\"set brightness %brightness\"\n    //% weight=1 blockGap=8\n    //% brightness.min=0 brightness.max=100\n    //% help=\"rgb/set-brightness\"\n    export function setBrightness(brightness: number): void {\n        _brightness = Math.max(0, Math.min(0xff, brightness >> 0));\n    }\n\n    /**\n     * Dim an RGB color to make a new color.\n     * @param rgb RGB color of the LED\n     * @param level dim level between 0 and 5 eg: 1\n     */\n    //% blockId=\"rgb_dim\" block=\"dim %rgb=rgb_colors |%level\"\n    //% level.min=0 level.max=5\n    //% weight=80 help=\"rgb/dim\"\n    export function dim(rgb: number, level: number): number {\n        if(level < 0)\n            level = 0;\n        if(level > 5)\n            level = 5;\n        return((((rgb & 0xFF0000) >> level) & 0xFF0000) |\n            (((rgb & 0x00FF00) >> level) & 0x00FF00) |\n            (((rgb & 0x0000FF) >> level) & 0x0000FF) );\n    }\n\n    /**\n     * Convert the red, green, blue color channels into an RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"rgb_rgbcolor\" block=\"red %red|green %green|blue %blue\"\n    //% red.min=0 red.max=255 green.min=0 green.max=255 blue.min=0 blue.max=255\n    //% weight=20 help=\"rgb/rgb\" blockGap=8 group=\"Colors\"\n    //% red.shadowOptions.color=\"#FF6680\"\n    //% green.shadowOptions.color=\"#59C059\"\n    //% blue.shadowOptions.color=\"#4C97FF\"\n    export function rgb(red: number, green: number, blue: number): number {\n        return ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);\n    }\n\n    /**\n     * Converts wheel position into an RGB color\n     * @param wheelPos value between 0 to 255 to get a color value, eg: 99\n     */\n    //% blockId=\"rgb_wheel\" block=\"color slider %wheelPos=colorWheelPicker\"\n    //% group=\"Colors\"\n    //% weight=19 help=\"rgb/wheel\" blockGap=8\n    export function wheel(wheelPos: number): number {\n        wheelPos = 255 - wheelPos;\n        if(wheelPos < 85) {\n            return rgb(wheelPos * 3, 255, 255 - wheelPos * 3);\n        }\n        if(wheelPos < 170) {\n            wheelPos -= 85;\n            return rgb(255, 255 - wheelPos * 3, wheelPos * 3);\n        }\n        wheelPos -= 170;\n        return rgb(255 - wheelPos * 3, wheelPos * 3, 255);\n    }\n\n    /**\n     * Get the RGB value of a known color\n    */\n    //% weight=10 blockGap=8\n    //% blockId=rgb_colors block=\"%color\"\n    //% help=rgb/colors\n    //% shim=TD_ID group=\"Colors\"\n    export function colors(color: Colors): number {\n        return color;\n    }\n\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb >> 0) & 0xFF;\n        return b;\n    }\n\n    function fade(color: number, brightness: number): number {\n        brightness = Math.max(0, Math.min(100, brightness >> 0));\n        brightness = Math.map(brightness, 0, 100, 0, 255);\n        if (brightness < 255) {\n            let red = unpackR(color);\n            let green = unpackG(color);\n            let blue = unpackB(color);\n\n            red = (red * brightness) >> 8;\n            green = (green * brightness) >> 8;\n            blue = (blue * brightness) >> 8;\n\n            color = rgb(red, green, blue);\n        }\n        return color;\n    }\n}",
      "ns.ts": "\n/**\n * Well known colors for the RGB Led\n */\nenum Colors {\n    //% block=red blockIdentity=rgb.colors\n    Red = 0xFF0000,\n    //% block=orange blockIdentity=rgb.colors\n    Orange = 0xFFA500,\n    //% block=yellow blockIdentity=rgb.colors\n    Yellow = 0xFFFF00,\n    //% block=green blockIdentity=rgb.colors\n    Green = 0x00FF00,\n    //% block=blue blockIdentity=rgb.colors\n    Blue = 0x0000FF,\n    //% block=indigo blockIdentity=rgb.colors\n    Indigo = 0x4b0082,\n    //% block=violet blockIdentity=rgb.colors\n    Violet = 0x8a2be2,\n    //% block=purple blockIdentity=rgb.colors\n    Purple = 0xFF00FF,\n    //% block=pink blockIdentity=rgb.colors\n    Pink = 0xFFC0CB,\n    //% block=white blockIdentity=rgb.colors\n    White = 0xFFFFFF,\n    //% block=black  blockIdentity=rgb.colors\n    Black = 0x000000\n}\n\n//% block=\"Light bulb\"\nnamespace lightbulb {\n\n    /**\n      * Get the color picker field editor\n      * @param color color, eg: 0xFF0000\n      */\n    //% blockId=colorNumberPicker block=\"%color\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% color.fieldEditor=\"colornumber\" color.fieldOptions.decompileLiterals=true\n    //% color.fieldOptions.colours='[\"#FF0000\", \"#ff8000\", \"#ffff00\", \"#00ff00\", \"#00ffff\", \"#007fff\", \"#0000ff\", \"#7f00ff\", \"#ff0080\", \"#ff00ff\", \"#ffffff\", \"#999999\"]'\n    //% color.fieldOptions.columns=3 color.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(color: number): number {\n        return color;\n    }\n\n    /**\n      * Get the color wheel field editor\n      * @param value value between 0 to 255 to get a color value, eg: 10\n      */\n    //% blockId=colorWheelPicker block=\"%color\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% color.fieldEditor=\"colorwheel\" color.fieldOptions.decompileLiterals=true\n    //% color.fieldOptions.sliderWidth='200' color.fieldOptions.channel=\"hsvfast\"\n    //% color.fieldOptions.min=0 color.fieldOptions.max=255\n    export function __colorWheelPicker(color: number): number {\n        return color;\n    }\n}",
      "pxt.json": "{\n  \"name\": \"lightbulb\",\n  \"description\": \"A lightbulb driver\",\n  \"files\": [\n    \"README.md\",\n    \"lightbulb.ts\",\n    \"lightbulb.cpp\",\n    \"shims.d.ts\",\n    \"ns.ts\"\n  ],\n  \"testFiles\": [\n    \"test.ts\"\n  ],\n  \"public\": true,\n  \"dependencies\": {\n    \"core\": \"*\"\n  }\n}",
      "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace lightbulb {\n\n    /**\n     * Set the rgb led to a specific red, green, blue color.\n     * @param red the red color\n     * @param green the green color\n     * @param blue the blue color\n     */\n    //% parts=\"rgbled\" shim=lightbulb::setRGBLed\n    function setRGBLed(r: int32, g: int32, b: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
      "test.ts": " "
    },
    "brainpad": {
      "README.md": "# brainpad\n\nThe GHI Electronics Brain Pad library.\n\n",
      "config.ts": "namespace config {\n    export const NUM_NEOPIXELS = 10;\n    export const DEFAULT_BUTTON_MODE = DAL.BUTTON_ACTIVE_HIGH_PULL_DOWN;\n\n    export const PIN_FLASH_MISO = DAL.PA16;\n    export const PIN_FLASH_MOSI = DAL.PA20;\n    export const PIN_FLASH_SCK = DAL.PA21;\n    export const PIN_FLASH_CS = DAL.PB22;\n    export const PIN_MIC_DATA = DAL.PA08;\n    export const PIN_MIC_CLOCK = DAL.PA10;\n    export const PIN_BTN_SLIDE = DAL.PA15;\n    export const PIN_NEOPIXEL = DAL.PB23;\n    export const PIN_SPEAKER_AMP = DAL.PA30;\n    export const PIN_MICROPHONE = DAL.PA08;\n    export const PIN_LIGHT = DAL.PA11;\n    export const PIN_ACCELEROMETER_SDA = DAL.PA00;\n    export const PIN_ACCELEROMETER_SCL = DAL.PA01;\n    export const PIN_ACCELEROMETER_INT = DAL.PA13;\n    export const PIN_TEMPERATURE = DAL.PA09;\n    export const PIN_IR_OUT = DAL.PA23;\n    export const PIN_IR_IN = DAL.PA12;\n    export const PIN_BTN_A = DAL.PA28;\n    export const PIN_BTN_B = DAL.PA14;\n\n    export const PIN_A0 = DAL.PA02;\n    export const PIN_A1 = DAL.PA05;\n    export const PIN_A2 = DAL.PA06;\n    export const PIN_A3 = DAL.PA07;\n    export const PIN_A4 = DAL.PB03;\n    export const PIN_A5 = DAL.PB02;\n    export const PIN_A6 = DAL.PB09;\n    export const PIN_A7 = DAL.PB08;\n    export const PIN_SCL = DAL.PB03;\n    export const PIN_SDA = DAL.PB02;\n    export const PIN_RX = DAL.PB09;\n    export const PIN_TX = DAL.PB08;\n    export const PIN_A8 = DAL.PA11;\n    export const PIN_A9 = DAL.PA09;\n    export const PIN_D4 = DAL.PA28;\n    export const PIN_D5 = DAL.PA14;\n    export const PIN_D7 = DAL.PA15;\n    export const PIN_D8 = DAL.PB23;\n    export const PIN_D13 = DAL.PA17;\n    export const PIN_LED = DAL.PA17;\n    export const PIN_A10 = DAL.PA08;\n}\n",
      "device.d.ts": "declare namespace pins {\n    // pin-pads\n    //% fixedInstance shim=pxt::getPin(PIN_A0)\n    const A0: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A1)\n    const A1: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A2)\n    const A2: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A3)\n    const A3: PwmPin;\n\n    //% fixedInstance shim=pxt::getPin(PIN_A4)\n    const A4: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A5)\n    const A5: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A6)\n    const A6: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A7)\n    const A7: PwmPin;\n\n    // Define aliases, as Digital Pins\n\n    //% fixedInstance shim=pxt::getPin(PIN_A4)\n    const SCL: DigitalPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A5)\n    const SDA: DigitalPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A6)\n    const RX: DigitalPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A7)\n    const TX: DigitalPin;\n\n    // Aliases for built-in components\n\n    //% fixedInstance shim=pxt::getPin(PIN_A8)\n    const A8: PwmPin; // light\n    //% fixedInstance shim=pxt::getPin(PIN_A9)\n    const A9: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_D4)\n    const D4: DigitalPin; // A\n    //% fixedInstance shim=pxt::getPin(PIN_D5)\n    const D5: DigitalPin; // B\n    //% fixedInstance shim=pxt::getPin(PIN_D7)\n    const D7: DigitalPin; // Slide\n    //% fixedInstance shim=pxt::getPin(PIN_D8)\n    const D8: DigitalPin; // Neopixel\n\n    //% fixedInstance shim=pxt::getPin(PIN_D13)\n    const D13: DigitalPin;\n    //% fixedInstance shim=pxt::getPin(PIN_D13)\n    const LED: DigitalPin;\n\n    //% fixedInstance shim=pxt::getPin(PIN_A10)\n    const A10: PwmPin; // mic\n}\n\n\ndeclare namespace input {\n    /**\n     * Left button.\n     */\n    //% indexedInstanceNS=input indexedInstanceShim=pxt::getButton\n    //% block=\"button Left\" weight=95 fixedInstance\n    //% shim=pxt::getButton(0)\n    const buttonL: Button;\n\n    /**\n     * Up button.\n     */\n    //% block=\"button Up\" weight=94 fixedInstance\n    //% shim=pxt::getButton(1)\n    const buttonU: Button;\n\n    /**\n     * Down button.\n     */\n    //% block=\"button Down\" weight=94 fixedInstance\n    //% shim=pxt::getButton(1)\n    const buttonD: Button;\n\n    /**\n     * Right button.\n     */\n    //% block=\"button Right\" weight=94 fixedInstance\n    //% shim=pxt::getButton(1)\n    const buttonR: Button;\n}\n\ndeclare namespace input {\n    /**\n     * Capacitive pin A1\n     */\n    //% block=\"pin A1\" fixedInstance shim=pxt::getTouchButton(PIN_A1)\n    const pinA1: TouchButton;\n\n    /**\n     * Capacitive pin A2\n     */\n    //% block=\"pin A2\" fixedInstance shim=pxt::getTouchButton(PIN_A2)\n    const pinA2: TouchButton;\n\n    /**\n     * Capacitive pin A3\n     */\n    //% block=\"pin A3\" fixedInstance shim=pxt::getTouchButton(PIN_A3)\n    const pinA3: TouchButton;\n\n    /**\n     * Capacitive pin A4\n     */\n    //% block=\"pin A4\" fixedInstance shim=pxt::getTouchButton(PIN_A4)\n    const pinA4: TouchButton;\n\n    /**\n     * Capacitive pin A5\n     */\n    //% block=\"pin A5\" fixedInstance shim=pxt::getTouchButton(PIN_A5)\n    const pinA5: TouchButton;\n\n    /**\n     * Capacitive pin A6\n     */\n    //% block=\"pin A6\" fixedInstance shim=pxt::getTouchButton(PIN_A6)\n    const pinA6: TouchButton;\n\n    /**\n     * Capacitive pin A7\n     */\n    //% block=\"pin A7\" fixedInstance shim=pxt::getTouchButton(PIN_A7)\n    const pinA7: TouchButton;\n}",
      "ns.ts": "\n//% color=\"#d65cd6\"\nnamespace input {\n}\n\n//% color=\"#0078d7\"\nnamespace lightbulb {\n\n}\n\n//% color=\"#F55D3E\"\nnamespace music {\n\n}\n\n//% color=\"#1B998B\"\nnamespace control {\n\n}\n\n//% color=\"#EF2D56\"\nnamespace pins {\n\n}\n\n//% color=\"#006E90\"\nnamespace serial {\n\n}\n\n//% color=\"#006E90\"\nnamespace console {\n\n}\n\n//% color=\"#40bf4a\"\nnamespace loops {\n\n}",
      "pxt.json": "{\n  \"name\": \"brainpad\",\n  \"description\": \"The GHI Electronics Brain Pad library\",\n  \"files\": [\n    \"README.md\",\n    \"device.d.ts\",\n    \"config.ts\",\n    \"ns.ts\"\n  ],\n  \"dependencies\": {\n    \"base\": \"*\",\n    \"core\": \"*\",\n    \"buttons\": \"*\",\n    \"accelerometer\": \"*\",\n    \"lightsensor\": \"*\",\n    \"thermometer\": \"*\",\n    \"music\": \"*\",\n    \"lightbulb\": \"*\",\n    \"switch\": \"*\",\n    \"pulse\": \"*\",\n    \"microphone\": \"*\",\n    \"touch\": \"*\"\n  },\n  \"public\": true\n}"
    }
  },
  "versions": {
    "target": "0.20.26",
    "pxt": "2.4.0"
  }
}